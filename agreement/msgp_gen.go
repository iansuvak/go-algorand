package agreement

// Code generated by github.com/algorand/msgp DO NOT EDIT.

import (
	"sort"

	"github.com/algorand/msgp/msgp"

	"github.com/algorand/go-algorand/config"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/algorand/go-algorand/data/bookkeeping"
	"github.com/algorand/go-algorand/protocol"
)

// The following msgp objects are implemented in this file:
// Certificate
//      |-----> (*) MarshalMsg
//      |-----> (*) CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> (*) Msgsize
//      |-----> (*) MsgIsZero
//
// ConsensusVersionView
//           |-----> (*) MarshalMsg
//           |-----> (*) CanMarshalMsg
//           |-----> (*) UnmarshalMsg
//           |-----> (*) CanUnmarshalMsg
//           |-----> (*) Msgsize
//           |-----> (*) MsgIsZero
//
// actionType
//      |-----> MarshalMsg
//      |-----> CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> Msgsize
//      |-----> MsgIsZero
//
// bundle
//    |-----> (*) MarshalMsg
//    |-----> (*) CanMarshalMsg
//    |-----> (*) UnmarshalMsg
//    |-----> (*) CanUnmarshalMsg
//    |-----> (*) Msgsize
//    |-----> (*) MsgIsZero
//
// checkedActor
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// checkpointAction
//         |-----> (*) MarshalMsg
//         |-----> (*) CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> (*) Msgsize
//         |-----> (*) MsgIsZero
//
// diskState
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//
// equivocationVote
//         |-----> (*) MarshalMsg
//         |-----> (*) CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> (*) Msgsize
//         |-----> (*) MsgIsZero
//
// equivocationVoteAuthenticator
//               |-----> (*) MarshalMsg
//               |-----> (*) CanMarshalMsg
//               |-----> (*) UnmarshalMsg
//               |-----> (*) CanUnmarshalMsg
//               |-----> (*) Msgsize
//               |-----> (*) MsgIsZero
//
// filterableMessageEvent
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//
// freshnessData
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// int
//  |-----> MarshalMsg
//  |-----> CanMarshalMsg
//  |-----> (*) UnmarshalMsg
//  |-----> (*) CanUnmarshalMsg
//  |-----> Msgsize
//  |-----> MsgIsZero
//
// ioLoggedActor
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// messageEvent
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// period
//    |-----> MarshalMsg
//    |-----> CanMarshalMsg
//    |-----> (*) UnmarshalMsg
//    |-----> (*) CanUnmarshalMsg
//    |-----> Msgsize
//    |-----> MsgIsZero
//
// player
//    |-----> (*) MarshalMsg
//    |-----> (*) CanMarshalMsg
//    |-----> (*) UnmarshalMsg
//    |-----> (*) CanUnmarshalMsg
//    |-----> (*) Msgsize
//    |-----> (*) MsgIsZero
//
// proposal
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//
// proposalTable
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// proposalValue
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// proposerSeed
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// pseudonodeAction
//         |-----> (*) MarshalMsg
//         |-----> (*) CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> (*) Msgsize
//         |-----> (*) MsgIsZero
//
// rawVote
//    |-----> (*) MarshalMsg
//    |-----> (*) CanMarshalMsg
//    |-----> (*) UnmarshalMsg
//    |-----> (*) CanUnmarshalMsg
//    |-----> (*) Msgsize
//    |-----> (*) MsgIsZero
//
// seedInput
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//
// selector
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//
// serializableErrorUnderlying
//              |-----> MarshalMsg
//              |-----> CanMarshalMsg
//              |-----> (*) UnmarshalMsg
//              |-----> (*) CanUnmarshalMsg
//              |-----> Msgsize
//              |-----> MsgIsZero
//
// step
//   |-----> MarshalMsg
//   |-----> CanMarshalMsg
//   |-----> (*) UnmarshalMsg
//   |-----> (*) CanUnmarshalMsg
//   |-----> Msgsize
//   |-----> MsgIsZero
//
// transmittedPayload
//          |-----> (*) MarshalMsg
//          |-----> (*) CanMarshalMsg
//          |-----> (*) UnmarshalMsg
//          |-----> (*) CanUnmarshalMsg
//          |-----> (*) Msgsize
//          |-----> (*) MsgIsZero
//
// unauthenticatedBundle
//           |-----> (*) MarshalMsg
//           |-----> (*) CanMarshalMsg
//           |-----> (*) UnmarshalMsg
//           |-----> (*) CanUnmarshalMsg
//           |-----> (*) Msgsize
//           |-----> (*) MsgIsZero
//
// unauthenticatedEquivocationVote
//                |-----> (*) MarshalMsg
//                |-----> (*) CanMarshalMsg
//                |-----> (*) UnmarshalMsg
//                |-----> (*) CanUnmarshalMsg
//                |-----> (*) Msgsize
//                |-----> (*) MsgIsZero
//
// unauthenticatedProposal
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//
// unauthenticatedVote
//          |-----> (*) MarshalMsg
//          |-----> (*) CanMarshalMsg
//          |-----> (*) UnmarshalMsg
//          |-----> (*) CanUnmarshalMsg
//          |-----> (*) Msgsize
//          |-----> (*) MsgIsZero
//
// vote
//   |-----> (*) MarshalMsg
//   |-----> (*) CanMarshalMsg
//   |-----> (*) UnmarshalMsg
//   |-----> (*) CanUnmarshalMsg
//   |-----> (*) Msgsize
//   |-----> (*) MsgIsZero
//
// voteAuthenticator
//         |-----> (*) MarshalMsg
//         |-----> (*) CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> (*) Msgsize
//         |-----> (*) MsgIsZero
//

// MarshalMsg implements msgp.Marshaler
func (z *Certificate) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(6)
	var zb0003Mask uint8 /* 7 bits */
	if len((*z).EquivocationVotes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).Period == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if (*z).Proposal.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if (*z).Step == 0 {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if len((*z).Votes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "eqv"
			o = append(o, 0xa3, 0x65, 0x71, 0x76)
			if (*z).EquivocationVotes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).EquivocationVotes)))
			}
			for zb0002 := range (*z).EquivocationVotes {
				o = (*z).EquivocationVotes[zb0002].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "prop"
			o = append(o, 0xa4, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).Proposal.MarshalMsg(o)
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "vote"
			o = append(o, 0xa4, 0x76, 0x6f, 0x74, 0x65)
			if (*z).Votes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Votes)))
			}
			for zb0001 := range (*z).Votes {
				o = (*z).Votes[zb0001].MarshalMsg(o)
			}
		}
	}
	return
}

func (_ *Certificate) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Certificate)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Certificate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0005)
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0006 uint64
				zb0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0006)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Proposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposal")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0007 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0007), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0008 {
				(*z).Votes = nil
			} else if (*z).Votes != nil && cap((*z).Votes) >= zb0007 {
				(*z).Votes = ((*z).Votes)[:zb0007]
			} else {
				(*z).Votes = make([]voteAuthenticator, zb0007)
			}
			for zb0001 := range (*z).Votes {
				bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Votes", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0009 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0010 {
				(*z).EquivocationVotes = nil
			} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0009 {
				(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0009]
			} else {
				(*z).EquivocationVotes = make([]equivocationVoteAuthenticator, zb0009)
			}
			for zb0002 := range (*z).EquivocationVotes {
				bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = Certificate{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "per":
				{
					var zb0011 uint64
					zb0011, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0011)
				}
			case "step":
				{
					var zb0012 uint64
					zb0012, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0012)
				}
			case "prop":
				bts, err = (*z).Proposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposal")
					return
				}
			case "vote":
				var zb0013 int
				var zb0014 bool
				zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0013 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0013), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0014 {
					(*z).Votes = nil
				} else if (*z).Votes != nil && cap((*z).Votes) >= zb0013 {
					(*z).Votes = ((*z).Votes)[:zb0013]
				} else {
					(*z).Votes = make([]voteAuthenticator, zb0013)
				}
				for zb0001 := range (*z).Votes {
					bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Votes", zb0001)
						return
					}
				}
			case "eqv":
				var zb0015 int
				var zb0016 bool
				zb0015, zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0015 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0015), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0016 {
					(*z).EquivocationVotes = nil
				} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0015 {
					(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0015]
				} else {
					(*z).EquivocationVotes = make([]equivocationVoteAuthenticator, zb0015)
				}
				for zb0002 := range (*z).EquivocationVotes {
					bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "EquivocationVotes", zb0002)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *Certificate) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Certificate)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Certificate) Msgsize() (s int) {
	s = 1 + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Proposal.Msgsize() + 5 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Votes {
		s += (*z).Votes[zb0001].Msgsize()
	}
	s += 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).EquivocationVotes {
		s += (*z).EquivocationVotes[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Certificate) MsgIsZero() bool {
	return ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Proposal.MsgIsZero()) && (len((*z).Votes) == 0) && (len((*z).EquivocationVotes) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *ConsensusVersionView) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 3 bits */
	if (*z).Err.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Version.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "err"
			o = append(o, 0xa3, 0x65, 0x72, 0x72)
			o = (*z).Err.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "v"
			o = append(o, 0xa1, 0x76)
			o = (*z).Version.MarshalMsg(o)
		}
	}
	return
}

func (_ *ConsensusVersionView) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*ConsensusVersionView)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ConsensusVersionView) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Err.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Err")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Version.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Version")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = ConsensusVersionView{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "err":
				bts, err = (*z).Err.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Err")
					return
				}
			case "v":
				bts, err = (*z).Version.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Version")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *ConsensusVersionView) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*ConsensusVersionView)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ConsensusVersionView) Msgsize() (s int) {
	s = 1 + 4 + (*z).Err.Msgsize() + 2 + (*z).Version.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *ConsensusVersionView) MsgIsZero() bool {
	return ((*z).Err.MsgIsZero()) && ((*z).Version.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z actionType) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

func (_ actionType) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(actionType)
	if !ok {
		_, ok = (z).(*actionType)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *actionType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint64
		zb0001, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = actionType(zb0001)
	}
	o = bts
	return
}

func (_ *actionType) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*actionType)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z actionType) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z actionType) MsgIsZero() bool {
	return z == 0
}

// MarshalMsg implements msgp.Marshaler
func (z *bundle) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(3)
	var zb0003Mask uint8 /* 4 bits */
	if len((*z).EquivocationVotes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).U.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if len((*z).Votes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "eqv"
			o = append(o, 0xa3, 0x65, 0x71, 0x76)
			if (*z).EquivocationVotes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).EquivocationVotes)))
			}
			for zb0002 := range (*z).EquivocationVotes {
				o = (*z).EquivocationVotes[zb0002].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "u"
			o = append(o, 0xa1, 0x75)
			o = (*z).U.MarshalMsg(o)
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "vote"
			o = append(o, 0xa4, 0x76, 0x6f, 0x74, 0x65)
			if (*z).Votes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Votes)))
			}
			for zb0001 := range (*z).Votes {
				o = (*z).Votes[zb0001].MarshalMsg(o)
			}
		}
	}
	return
}

func (_ *bundle) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*bundle)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *bundle) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).U.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "U")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0005 int
			var zb0006 bool
			zb0005, zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0005 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0005), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0006 {
				(*z).Votes = nil
			} else if (*z).Votes != nil && cap((*z).Votes) >= zb0005 {
				(*z).Votes = ((*z).Votes)[:zb0005]
			} else {
				(*z).Votes = make([]vote, zb0005)
			}
			for zb0001 := range (*z).Votes {
				bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Votes", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0007 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0007), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0008 {
				(*z).EquivocationVotes = nil
			} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0007 {
				(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0007]
			} else {
				(*z).EquivocationVotes = make([]equivocationVote, zb0007)
			}
			for zb0002 := range (*z).EquivocationVotes {
				bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = bundle{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "u":
				bts, err = (*z).U.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "U")
					return
				}
			case "vote":
				var zb0009 int
				var zb0010 bool
				zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0009 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0009), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0010 {
					(*z).Votes = nil
				} else if (*z).Votes != nil && cap((*z).Votes) >= zb0009 {
					(*z).Votes = ((*z).Votes)[:zb0009]
				} else {
					(*z).Votes = make([]vote, zb0009)
				}
				for zb0001 := range (*z).Votes {
					bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Votes", zb0001)
						return
					}
				}
			case "eqv":
				var zb0011 int
				var zb0012 bool
				zb0011, zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0011 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0011), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0012 {
					(*z).EquivocationVotes = nil
				} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0011 {
					(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0011]
				} else {
					(*z).EquivocationVotes = make([]equivocationVote, zb0011)
				}
				for zb0002 := range (*z).EquivocationVotes {
					bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "EquivocationVotes", zb0002)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *bundle) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*bundle)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *bundle) Msgsize() (s int) {
	s = 1 + 2 + (*z).U.Msgsize() + 5 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Votes {
		s += (*z).Votes[zb0001].Msgsize()
	}
	s += 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).EquivocationVotes {
		s += (*z).EquivocationVotes[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *bundle) MsgIsZero() bool {
	return ((*z).U.MsgIsZero()) && (len((*z).Votes) == 0) && (len((*z).EquivocationVotes) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *checkedActor) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(0)
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
	}
	return
}

func (_ *checkedActor) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*checkedActor)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *checkedActor) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = checkedActor{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *checkedActor) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*checkedActor)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *checkedActor) Msgsize() (s int) {
	s = 1
	return
}

// MsgIsZero returns whether this is a zero value
func (z *checkedActor) MsgIsZero() bool {
	return true
}

// MarshalMsg implements msgp.Marshaler
func (z *checkpointAction) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 5 bits */
	if (*z).Err.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Period == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Round.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).Step == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "err"
			o = append(o, 0xa3, 0x65, 0x72, 0x72)
			o = (*z).Err.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "p"
			o = append(o, 0xa1, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "s"
			o = append(o, 0xa1, 0x73)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
	}
	return
}

func (_ *checkpointAction) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*checkpointAction)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *checkpointAction) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0003 uint64
				zb0003, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0003)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0004 uint64
				zb0004, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0004)
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Err.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Err")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = checkpointAction{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "r":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "p":
				{
					var zb0005 uint64
					zb0005, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0005)
				}
			case "s":
				{
					var zb0006 uint64
					zb0006, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0006)
				}
			case "err":
				bts, err = (*z).Err.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Err")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *checkpointAction) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*checkpointAction)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *checkpointAction) Msgsize() (s int) {
	s = 1 + 2 + (*z).Round.Msgsize() + 2 + msgp.Uint64Size + 2 + msgp.Uint64Size + 4 + (*z).Err.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *checkpointAction) MsgIsZero() bool {
	return ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Err.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *diskState) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(5)
	var zb0003Mask uint8 /* 6 bits */
	if len((*z).Actions) == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if len((*z).ActionTypes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if len((*z).Clock) == 0 {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if len((*z).Player) == 0 {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if len((*z).Router) == 0 {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "as"
			o = append(o, 0xa2, 0x61, 0x73)
			if (*z).Actions == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Actions)))
			}
			for zb0002 := range (*z).Actions {
				o = msgp.AppendBytes(o, (*z).Actions[zb0002])
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "ats"
			o = append(o, 0xa3, 0x61, 0x74, 0x73)
			if (*z).ActionTypes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).ActionTypes)))
			}
			for zb0001 := range (*z).ActionTypes {
				o = msgp.AppendUint64(o, uint64((*z).ActionTypes[zb0001]))
			}
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "c"
			o = append(o, 0xa1, 0x63)
			o = msgp.AppendBytes(o, (*z).Clock)
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "p"
			o = append(o, 0xa1, 0x70)
			o = msgp.AppendBytes(o, (*z).Player)
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = msgp.AppendBytes(o, (*z).Router)
		}
	}
	return
}

func (_ *diskState) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*diskState)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *diskState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Router, bts, err = msgp.ReadBytesBytes(bts, (*z).Router)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Router")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Player, bts, err = msgp.ReadBytesBytes(bts, (*z).Player)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Player")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Clock, bts, err = msgp.ReadBytesBytes(bts, (*z).Clock)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Clock")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0005 int
			var zb0006 bool
			zb0005, zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ActionTypes")
				return
			}
			if zb0006 {
				(*z).ActionTypes = nil
			} else if (*z).ActionTypes != nil && cap((*z).ActionTypes) >= zb0005 {
				(*z).ActionTypes = ((*z).ActionTypes)[:zb0005]
			} else {
				(*z).ActionTypes = make([]actionType, zb0005)
			}
			for zb0001 := range (*z).ActionTypes {
				{
					var zb0007 uint64
					zb0007, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ActionTypes", zb0001)
						return
					}
					(*z).ActionTypes[zb0001] = actionType(zb0007)
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0008 int
			var zb0009 bool
			zb0008, zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Actions")
				return
			}
			if zb0009 {
				(*z).Actions = nil
			} else if (*z).Actions != nil && cap((*z).Actions) >= zb0008 {
				(*z).Actions = ((*z).Actions)[:zb0008]
			} else {
				(*z).Actions = make([][]byte, zb0008)
			}
			for zb0002 := range (*z).Actions {
				(*z).Actions[zb0002], bts, err = msgp.ReadBytesBytes(bts, (*z).Actions[zb0002])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Actions", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = diskState{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "r":
				(*z).Router, bts, err = msgp.ReadBytesBytes(bts, (*z).Router)
				if err != nil {
					err = msgp.WrapError(err, "Router")
					return
				}
			case "p":
				(*z).Player, bts, err = msgp.ReadBytesBytes(bts, (*z).Player)
				if err != nil {
					err = msgp.WrapError(err, "Player")
					return
				}
			case "c":
				(*z).Clock, bts, err = msgp.ReadBytesBytes(bts, (*z).Clock)
				if err != nil {
					err = msgp.WrapError(err, "Clock")
					return
				}
			case "ats":
				var zb0010 int
				var zb0011 bool
				zb0010, zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ActionTypes")
					return
				}
				if zb0011 {
					(*z).ActionTypes = nil
				} else if (*z).ActionTypes != nil && cap((*z).ActionTypes) >= zb0010 {
					(*z).ActionTypes = ((*z).ActionTypes)[:zb0010]
				} else {
					(*z).ActionTypes = make([]actionType, zb0010)
				}
				for zb0001 := range (*z).ActionTypes {
					{
						var zb0012 uint64
						zb0012, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "ActionTypes", zb0001)
							return
						}
						(*z).ActionTypes[zb0001] = actionType(zb0012)
					}
				}
			case "as":
				var zb0013 int
				var zb0014 bool
				zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Actions")
					return
				}
				if zb0014 {
					(*z).Actions = nil
				} else if (*z).Actions != nil && cap((*z).Actions) >= zb0013 {
					(*z).Actions = ((*z).Actions)[:zb0013]
				} else {
					(*z).Actions = make([][]byte, zb0013)
				}
				for zb0002 := range (*z).Actions {
					(*z).Actions[zb0002], bts, err = msgp.ReadBytesBytes(bts, (*z).Actions[zb0002])
					if err != nil {
						err = msgp.WrapError(err, "Actions", zb0002)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *diskState) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*diskState)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *diskState) Msgsize() (s int) {
	s = 1 + 2 + msgp.BytesPrefixSize + len((*z).Router) + 2 + msgp.BytesPrefixSize + len((*z).Player) + 2 + msgp.BytesPrefixSize + len((*z).Clock) + 4 + msgp.ArrayHeaderSize + (len((*z).ActionTypes) * (msgp.Uint64Size)) + 3 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Actions {
		s += msgp.BytesPrefixSize + len((*z).Actions[zb0002])
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *diskState) MsgIsZero() bool {
	return (len((*z).Router) == 0) && (len((*z).Player) == 0) && (len((*z).Clock) == 0) && (len((*z).ActionTypes) == 0) && (len((*z).Actions) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *equivocationVote) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(7)
	var zb0003Mask uint8 /* 8 bits */
	if (*z).Cred.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).Period == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if ((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero()) {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if ((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero()) {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if (*z).Sender.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	if (*z).Step == 0 {
		zb0003Len--
		zb0003Mask |= 0x80
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "cred"
			o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
			o = (*z).Cred.MarshalMsg(o)
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "props"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x70, 0x73)
			o = msgp.AppendArrayHeader(o, 2)
			for zb0001 := range (*z).Proposals {
				o = (*z).Proposals[zb0001].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "sigs"
			o = append(o, 0xa4, 0x73, 0x69, 0x67, 0x73)
			o = msgp.AppendArrayHeader(o, 2)
			for zb0002 := range (*z).Sigs {
				o = (*z).Sigs[zb0002].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o = (*z).Sender.MarshalMsg(o)
		}
		if (zb0003Mask & 0x80) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
	}
	return
}

func (_ *equivocationVote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*equivocationVote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *equivocationVote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0005)
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0006 uint64
				zb0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0006)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			zb0007, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposals")
				return
			}
			if zb0007 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0007}
				return
			}
			for zb0001 := 0; zb0001 < zb0007; zb0001++ {
				bts, err = (*z).Proposals[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Proposals", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0008 int
			zb0008, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sigs")
				return
			}
			if zb0008 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0008}
				return
			}
			for zb0002 := 0; zb0002 < zb0008; zb0002++ {
				bts, err = (*z).Sigs[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sigs", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = equivocationVote{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "rnd":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "per":
				{
					var zb0009 uint64
					zb0009, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0009)
				}
			case "step":
				{
					var zb0010 uint64
					zb0010, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0010)
				}
			case "cred":
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
			case "props":
				var zb0011 int
				zb0011, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposals")
					return
				}
				if zb0011 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0011}
					return
				}
				for zb0001 := 0; zb0001 < zb0011; zb0001++ {
					bts, err = (*z).Proposals[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Proposals", zb0001)
						return
					}
				}
			case "sigs":
				var zb0012 int
				zb0012, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sigs")
					return
				}
				if zb0012 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0012}
					return
				}
				for zb0002 := 0; zb0002 < zb0012; zb0002++ {
					bts, err = (*z).Sigs[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sigs", zb0002)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *equivocationVote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*equivocationVote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *equivocationVote) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Cred.Msgsize() + 6 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Proposals {
		s += (*z).Proposals[zb0001].Msgsize()
	}
	s += 5 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Sigs {
		s += (*z).Sigs[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *equivocationVote) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Cred.MsgIsZero()) && (((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero())) && (((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero()))
}

// MarshalMsg implements msgp.Marshaler
func (z *equivocationVoteAuthenticator) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(4)
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		// string "cred"
		o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
		o = (*z).Cred.MarshalMsg(o)
		// string "props"
		o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x70, 0x73)
		o = msgp.AppendArrayHeader(o, 2)
		for zb0002 := range (*z).Proposals {
			o = (*z).Proposals[zb0002].MarshalMsg(o)
		}
		// string "sig"
		o = append(o, 0xa3, 0x73, 0x69, 0x67)
		o = msgp.AppendArrayHeader(o, 2)
		for zb0001 := range (*z).Sigs {
			o = (*z).Sigs[zb0001].MarshalMsg(o)
		}
		// string "snd"
		o = append(o, 0xa3, 0x73, 0x6e, 0x64)
		o = (*z).Sender.MarshalMsg(o)
	}
	return
}

func (_ *equivocationVoteAuthenticator) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*equivocationVoteAuthenticator)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *equivocationVoteAuthenticator) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0005 int
			zb0005, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sigs")
				return
			}
			if zb0005 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0005}
				return
			}
			for zb0001 := 0; zb0001 < zb0005; zb0001++ {
				bts, err = (*z).Sigs[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sigs", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0006 int
			zb0006, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposals")
				return
			}
			if zb0006 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0006}
				return
			}
			for zb0002 := 0; zb0002 < zb0006; zb0002++ {
				bts, err = (*z).Proposals[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Proposals", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = equivocationVoteAuthenticator{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "cred":
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
			case "sig":
				var zb0007 int
				zb0007, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sigs")
					return
				}
				if zb0007 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0007}
					return
				}
				for zb0001 := 0; zb0001 < zb0007; zb0001++ {
					bts, err = (*z).Sigs[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sigs", zb0001)
						return
					}
				}
			case "props":
				var zb0008 int
				zb0008, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposals")
					return
				}
				if zb0008 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0008}
					return
				}
				for zb0002 := 0; zb0002 < zb0008; zb0002++ {
					bts, err = (*z).Proposals[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Proposals", zb0002)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *equivocationVoteAuthenticator) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*equivocationVoteAuthenticator)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *equivocationVoteAuthenticator) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 5 + (*z).Cred.Msgsize() + 4 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Sigs {
		s += (*z).Sigs[zb0001].Msgsize()
	}
	s += 6 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Proposals {
		s += (*z).Proposals[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *equivocationVoteAuthenticator) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Cred.MsgIsZero()) && (((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero())) && (((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero()))
}

// MarshalMsg implements msgp.Marshaler
func (z *filterableMessageEvent) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(8)
	var zb0001Mask uint16 /* 10 bits */
	if ((*z).messageEvent.Proto.Err.MsgIsZero()) && ((*z).messageEvent.Proto.Version.MsgIsZero()) {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if (*z).messageEvent.T.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).messageEvent.Cancelled == false {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).messageEvent.Err.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if (*z).FreshnessData.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if (*z).messageEvent.Input.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if (*z).messageEvent.Tail == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if (*z).messageEvent.TaskIndex == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not empty
			// string "Proto"
			o = append(o, 0xa5, 0x50, 0x72, 0x6f, 0x74, 0x6f)
			// omitempty: check for empty values
			zb0002Len := uint32(2)
			var zb0002Mask uint8 /* 3 bits */
			if (*z).messageEvent.Proto.Err.MsgIsZero() {
				zb0002Len--
				zb0002Mask |= 0x2
			}
			if (*z).messageEvent.Proto.Version.MsgIsZero() {
				zb0002Len--
				zb0002Mask |= 0x4
			}
			// variable map header, size zb0002Len
			o = append(o, 0x80|uint8(zb0002Len))
			if (zb0002Mask & 0x2) == 0 { // if not empty
				// string "err"
				o = append(o, 0xa3, 0x65, 0x72, 0x72)
				o = (*z).messageEvent.Proto.Err.MarshalMsg(o)
			}
			if (zb0002Mask & 0x4) == 0 { // if not empty
				// string "v"
				o = append(o, 0xa1, 0x76)
				o = (*z).messageEvent.Proto.Version.MarshalMsg(o)
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "T"
			o = append(o, 0xa1, 0x54)
			o = (*z).messageEvent.T.MarshalMsg(o)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "c"
			o = append(o, 0xa1, 0x63)
			o = msgp.AppendBool(o, (*z).messageEvent.Cancelled)
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "err"
			o = append(o, 0xa3, 0x65, 0x72, 0x72)
			o = (*z).messageEvent.Err.MarshalMsg(o)
		}
		if (zb0001Mask & 0x40) == 0 { // if not empty
			// string "fd"
			o = append(o, 0xa2, 0x66, 0x64)
			o = (*z).FreshnessData.MarshalMsg(o)
		}
		if (zb0001Mask & 0x80) == 0 { // if not empty
			// string "msg"
			o = append(o, 0xa3, 0x6d, 0x73, 0x67)
			o = (*z).messageEvent.Input.MarshalMsg(o)
		}
		if (zb0001Mask & 0x100) == 0 { // if not empty
			// string "tail"
			o = append(o, 0xa4, 0x74, 0x61, 0x69, 0x6c)
			if (*z).messageEvent.Tail == nil {
				o = msgp.AppendNil(o)
			} else {
				o = (*z).messageEvent.Tail.MarshalMsg(o)
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not empty
			// string "tidx"
			o = append(o, 0xa4, 0x74, 0x69, 0x64, 0x78)
			o = msgp.AppendUint64(o, uint64((*z).messageEvent.TaskIndex))
		}
	}
	return
}

func (_ *filterableMessageEvent) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*filterableMessageEvent)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *filterableMessageEvent) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).messageEvent.T.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "T")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).messageEvent.Input.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Input")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).messageEvent.Err.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Err")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0003 uint64
				zb0003, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "TaskIndex")
					return
				}
				(*z).messageEvent.TaskIndex = int(zb0003)
			}
		}
		if zb0001 > 0 {
			zb0001--
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				(*z).messageEvent.Tail = nil
			} else {
				if (*z).messageEvent.Tail == nil {
					(*z).messageEvent.Tail = new(messageEvent)
				}
				bts, err = (*z).messageEvent.Tail.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Tail")
					return
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).messageEvent.Cancelled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cancelled")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0004 int
			var zb0005 bool
			zb0004, zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Proto")
					return
				}
				if zb0004 > 0 {
					zb0004--
					bts, err = (*z).messageEvent.Proto.Err.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Proto", "struct-from-array", "Err")
						return
					}
				}
				if zb0004 > 0 {
					zb0004--
					bts, err = (*z).messageEvent.Proto.Version.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Proto", "struct-from-array", "Version")
						return
					}
				}
				if zb0004 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0004)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Proto", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Proto")
					return
				}
				if zb0005 {
					(*z).messageEvent.Proto = ConsensusVersionView{}
				}
				for zb0004 > 0 {
					zb0004--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Proto")
						return
					}
					switch string(field) {
					case "err":
						bts, err = (*z).messageEvent.Proto.Err.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Proto", "Err")
							return
						}
					case "v":
						bts, err = (*z).messageEvent.Proto.Version.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Proto", "Version")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Proto")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).FreshnessData.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreshnessData")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = filterableMessageEvent{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "T":
				bts, err = (*z).messageEvent.T.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "T")
					return
				}
			case "msg":
				bts, err = (*z).messageEvent.Input.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Input")
					return
				}
			case "err":
				bts, err = (*z).messageEvent.Err.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Err")
					return
				}
			case "tidx":
				{
					var zb0006 uint64
					zb0006, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "TaskIndex")
						return
					}
					(*z).messageEvent.TaskIndex = int(zb0006)
				}
			case "tail":
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					(*z).messageEvent.Tail = nil
				} else {
					if (*z).messageEvent.Tail == nil {
						(*z).messageEvent.Tail = new(messageEvent)
					}
					bts, err = (*z).messageEvent.Tail.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Tail")
						return
					}
				}
			case "c":
				(*z).messageEvent.Cancelled, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cancelled")
					return
				}
			case "Proto":
				var zb0007 int
				var zb0008 bool
				zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Proto")
						return
					}
					if zb0007 > 0 {
						zb0007--
						bts, err = (*z).messageEvent.Proto.Err.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Proto", "struct-from-array", "Err")
							return
						}
					}
					if zb0007 > 0 {
						zb0007--
						bts, err = (*z).messageEvent.Proto.Version.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Proto", "struct-from-array", "Version")
							return
						}
					}
					if zb0007 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0007)
						if err != nil {
							err = msgp.WrapError(err, "Proto", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "Proto")
						return
					}
					if zb0008 {
						(*z).messageEvent.Proto = ConsensusVersionView{}
					}
					for zb0007 > 0 {
						zb0007--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Proto")
							return
						}
						switch string(field) {
						case "err":
							bts, err = (*z).messageEvent.Proto.Err.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Proto", "Err")
								return
							}
						case "v":
							bts, err = (*z).messageEvent.Proto.Version.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Proto", "Version")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "Proto")
								return
							}
						}
					}
				}
			case "fd":
				bts, err = (*z).FreshnessData.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FreshnessData")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *filterableMessageEvent) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*filterableMessageEvent)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *filterableMessageEvent) Msgsize() (s int) {
	s = 1 + 2 + (*z).messageEvent.T.Msgsize() + 4 + (*z).messageEvent.Input.Msgsize() + 4 + (*z).messageEvent.Err.Msgsize() + 5 + msgp.Uint64Size + 5
	if (*z).messageEvent.Tail == nil {
		s += msgp.NilSize
	} else {
		s += (*z).messageEvent.Tail.Msgsize()
	}
	s += 2 + msgp.BoolSize + 6 + 1 + 4 + (*z).messageEvent.Proto.Err.Msgsize() + 2 + (*z).messageEvent.Proto.Version.Msgsize() + 3 + (*z).FreshnessData.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *filterableMessageEvent) MsgIsZero() bool {
	return ((*z).messageEvent.T.MsgIsZero()) && ((*z).messageEvent.Input.MsgIsZero()) && ((*z).messageEvent.Err.MsgIsZero()) && ((*z).messageEvent.TaskIndex == 0) && ((*z).messageEvent.Tail == nil) && ((*z).messageEvent.Cancelled == false) && (((*z).messageEvent.Proto.Err.MsgIsZero()) && ((*z).messageEvent.Proto.Version.MsgIsZero())) && ((*z).FreshnessData.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *freshnessData) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 5 bits */
	if (*z).PlayerLastConcluding == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).PlayerPeriod == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).PlayerRound.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).PlayerStep == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "plc"
			o = append(o, 0xa3, 0x70, 0x6c, 0x63)
			o = msgp.AppendUint64(o, uint64((*z).PlayerLastConcluding))
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "pp"
			o = append(o, 0xa2, 0x70, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).PlayerPeriod))
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "pr"
			o = append(o, 0xa2, 0x70, 0x72)
			o = (*z).PlayerRound.MarshalMsg(o)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "ps"
			o = append(o, 0xa2, 0x70, 0x73)
			o = msgp.AppendUint64(o, uint64((*z).PlayerStep))
		}
	}
	return
}

func (_ *freshnessData) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*freshnessData)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *freshnessData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).PlayerRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PlayerRound")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0003 uint64
				zb0003, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PlayerPeriod")
					return
				}
				(*z).PlayerPeriod = period(zb0003)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0004 uint64
				zb0004, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PlayerStep")
					return
				}
				(*z).PlayerStep = step(zb0004)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PlayerLastConcluding")
					return
				}
				(*z).PlayerLastConcluding = step(zb0005)
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = freshnessData{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "pr":
				bts, err = (*z).PlayerRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "PlayerRound")
					return
				}
			case "pp":
				{
					var zb0006 uint64
					zb0006, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PlayerPeriod")
						return
					}
					(*z).PlayerPeriod = period(zb0006)
				}
			case "ps":
				{
					var zb0007 uint64
					zb0007, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PlayerStep")
						return
					}
					(*z).PlayerStep = step(zb0007)
				}
			case "plc":
				{
					var zb0008 uint64
					zb0008, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PlayerLastConcluding")
						return
					}
					(*z).PlayerLastConcluding = step(zb0008)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *freshnessData) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*freshnessData)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *freshnessData) Msgsize() (s int) {
	s = 1 + 3 + (*z).PlayerRound.Msgsize() + 3 + msgp.Uint64Size + 3 + msgp.Uint64Size + 4 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *freshnessData) MsgIsZero() bool {
	return ((*z).PlayerRound.MsgIsZero()) && ((*z).PlayerPeriod == 0) && ((*z).PlayerStep == 0) && ((*z).PlayerLastConcluding == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z int) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

func (_ int) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(int)
	if !ok {
		_, ok = (z).(*int)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *int) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint64
		zb0001, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = int(zb0001)
	}
	o = bts
	return
}

func (_ *int) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*int)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z int) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z int) MsgIsZero() bool {
	return z == 0
}

// MarshalMsg implements msgp.Marshaler
func (z *ioLoggedActor) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(0)
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
	}
	return
}

func (_ *ioLoggedActor) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*ioLoggedActor)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ioLoggedActor) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = ioLoggedActor{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *ioLoggedActor) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*ioLoggedActor)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ioLoggedActor) Msgsize() (s int) {
	s = 1
	return
}

// MsgIsZero returns whether this is a zero value
func (z *ioLoggedActor) MsgIsZero() bool {
	return true
}

// MarshalMsg implements msgp.Marshaler
func (z *messageEvent) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(7)
	var zb0001Mask uint8 /* 8 bits */
	if ((*z).Proto.Err.MsgIsZero()) && ((*z).Proto.Version.MsgIsZero()) {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if (*z).T.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Cancelled == false {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).Err.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).Input.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if (*z).Tail == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if (*z).TaskIndex == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not empty
			// string "Proto"
			o = append(o, 0xa5, 0x50, 0x72, 0x6f, 0x74, 0x6f)
			// omitempty: check for empty values
			zb0002Len := uint32(2)
			var zb0002Mask uint8 /* 3 bits */
			if (*z).Proto.Err.MsgIsZero() {
				zb0002Len--
				zb0002Mask |= 0x2
			}
			if (*z).Proto.Version.MsgIsZero() {
				zb0002Len--
				zb0002Mask |= 0x4
			}
			// variable map header, size zb0002Len
			o = append(o, 0x80|uint8(zb0002Len))
			if (zb0002Mask & 0x2) == 0 { // if not empty
				// string "err"
				o = append(o, 0xa3, 0x65, 0x72, 0x72)
				o = (*z).Proto.Err.MarshalMsg(o)
			}
			if (zb0002Mask & 0x4) == 0 { // if not empty
				// string "v"
				o = append(o, 0xa1, 0x76)
				o = (*z).Proto.Version.MarshalMsg(o)
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "T"
			o = append(o, 0xa1, 0x54)
			o = (*z).T.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "c"
			o = append(o, 0xa1, 0x63)
			o = msgp.AppendBool(o, (*z).Cancelled)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "err"
			o = append(o, 0xa3, 0x65, 0x72, 0x72)
			o = (*z).Err.MarshalMsg(o)
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "msg"
			o = append(o, 0xa3, 0x6d, 0x73, 0x67)
			o = (*z).Input.MarshalMsg(o)
		}
		if (zb0001Mask & 0x40) == 0 { // if not empty
			// string "tail"
			o = append(o, 0xa4, 0x74, 0x61, 0x69, 0x6c)
			if (*z).Tail == nil {
				o = msgp.AppendNil(o)
			} else {
				o = (*z).Tail.MarshalMsg(o)
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not empty
			// string "tidx"
			o = append(o, 0xa4, 0x74, 0x69, 0x64, 0x78)
			o = msgp.AppendUint64(o, uint64((*z).TaskIndex))
		}
	}
	return
}

func (_ *messageEvent) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*messageEvent)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *messageEvent) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).T.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "T")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Input.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Input")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Err.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Err")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0003 uint64
				zb0003, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "TaskIndex")
					return
				}
				(*z).TaskIndex = int(zb0003)
			}
		}
		if zb0001 > 0 {
			zb0001--
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				(*z).Tail = nil
			} else {
				if (*z).Tail == nil {
					(*z).Tail = new(messageEvent)
				}
				bts, err = (*z).Tail.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Tail")
					return
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Cancelled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cancelled")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0004 int
			var zb0005 bool
			zb0004, zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Proto")
					return
				}
				if zb0004 > 0 {
					zb0004--
					bts, err = (*z).Proto.Err.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Proto", "struct-from-array", "Err")
						return
					}
				}
				if zb0004 > 0 {
					zb0004--
					bts, err = (*z).Proto.Version.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Proto", "struct-from-array", "Version")
						return
					}
				}
				if zb0004 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0004)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Proto", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Proto")
					return
				}
				if zb0005 {
					(*z).Proto = ConsensusVersionView{}
				}
				for zb0004 > 0 {
					zb0004--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Proto")
						return
					}
					switch string(field) {
					case "err":
						bts, err = (*z).Proto.Err.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Proto", "Err")
							return
						}
					case "v":
						bts, err = (*z).Proto.Version.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Proto", "Version")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Proto")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = messageEvent{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "T":
				bts, err = (*z).T.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "T")
					return
				}
			case "msg":
				bts, err = (*z).Input.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Input")
					return
				}
			case "err":
				bts, err = (*z).Err.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Err")
					return
				}
			case "tidx":
				{
					var zb0006 uint64
					zb0006, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "TaskIndex")
						return
					}
					(*z).TaskIndex = int(zb0006)
				}
			case "tail":
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					(*z).Tail = nil
				} else {
					if (*z).Tail == nil {
						(*z).Tail = new(messageEvent)
					}
					bts, err = (*z).Tail.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Tail")
						return
					}
				}
			case "c":
				(*z).Cancelled, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cancelled")
					return
				}
			case "Proto":
				var zb0007 int
				var zb0008 bool
				zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Proto")
						return
					}
					if zb0007 > 0 {
						zb0007--
						bts, err = (*z).Proto.Err.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Proto", "struct-from-array", "Err")
							return
						}
					}
					if zb0007 > 0 {
						zb0007--
						bts, err = (*z).Proto.Version.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Proto", "struct-from-array", "Version")
							return
						}
					}
					if zb0007 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0007)
						if err != nil {
							err = msgp.WrapError(err, "Proto", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "Proto")
						return
					}
					if zb0008 {
						(*z).Proto = ConsensusVersionView{}
					}
					for zb0007 > 0 {
						zb0007--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Proto")
							return
						}
						switch string(field) {
						case "err":
							bts, err = (*z).Proto.Err.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Proto", "Err")
								return
							}
						case "v":
							bts, err = (*z).Proto.Version.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Proto", "Version")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "Proto")
								return
							}
						}
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *messageEvent) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*messageEvent)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *messageEvent) Msgsize() (s int) {
	s = 1 + 2 + (*z).T.Msgsize() + 4 + (*z).Input.Msgsize() + 4 + (*z).Err.Msgsize() + 5 + msgp.Uint64Size + 5
	if (*z).Tail == nil {
		s += msgp.NilSize
	} else {
		s += (*z).Tail.Msgsize()
	}
	s += 2 + msgp.BoolSize + 6 + 1 + 4 + (*z).Proto.Err.Msgsize() + 2 + (*z).Proto.Version.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *messageEvent) MsgIsZero() bool {
	return ((*z).T.MsgIsZero()) && ((*z).Input.MsgIsZero()) && ((*z).Err.MsgIsZero()) && ((*z).TaskIndex == 0) && ((*z).Tail == nil) && ((*z).Cancelled == false) && (((*z).Proto.Err.MsgIsZero()) && ((*z).Proto.Version.MsgIsZero()))
}

// MarshalMsg implements msgp.Marshaler
func (z period) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

func (_ period) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(period)
	if !ok {
		_, ok = (z).(*period)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *period) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint64
		zb0001, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = period(zb0001)
	}
	o = bts
	return
}

func (_ *period) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*period)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z period) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z period) MsgIsZero() bool {
	return z == 0
}

// MarshalMsg implements msgp.Marshaler
func (z *player) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(8)
	var zb0001Mask uint16 /* 9 bits */
	if (*z).Pending.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if (*z).Deadline == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).FastRecoveryDeadline == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).LastConcluding == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).Napping == false {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if (*z).Period == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if (*z).Round.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if (*z).Step == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not empty
			// string "Pending"
			o = append(o, 0xa7, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67)
			o = (*z).Pending.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "dl"
			o = append(o, 0xa2, 0x64, 0x6c)
			o = msgp.AppendDuration(o, (*z).Deadline)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "frd"
			o = append(o, 0xa3, 0x66, 0x72, 0x64)
			o = msgp.AppendDuration(o, (*z).FastRecoveryDeadline)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "lc"
			o = append(o, 0xa2, 0x6c, 0x63)
			o = msgp.AppendUint64(o, uint64((*z).LastConcluding))
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "n"
			o = append(o, 0xa1, 0x6e)
			o = msgp.AppendBool(o, (*z).Napping)
		}
		if (zb0001Mask & 0x40) == 0 { // if not empty
			// string "p"
			o = append(o, 0xa1, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0001Mask & 0x80) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0001Mask & 0x100) == 0 { // if not empty
			// string "s"
			o = append(o, 0xa1, 0x73)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
	}
	return
}

func (_ *player) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*player)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *player) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0003 uint64
				zb0003, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0003)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0004 uint64
				zb0004, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0004)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LastConcluding")
					return
				}
				(*z).LastConcluding = step(zb0005)
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Deadline, bts, err = msgp.ReadDurationBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Deadline")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Napping, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Napping")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).FastRecoveryDeadline, bts, err = msgp.ReadDurationBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FastRecoveryDeadline")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Pending.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Pending")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = player{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "r":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "p":
				{
					var zb0006 uint64
					zb0006, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0006)
				}
			case "s":
				{
					var zb0007 uint64
					zb0007, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0007)
				}
			case "lc":
				{
					var zb0008 uint64
					zb0008, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastConcluding")
						return
					}
					(*z).LastConcluding = step(zb0008)
				}
			case "dl":
				(*z).Deadline, bts, err = msgp.ReadDurationBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Deadline")
					return
				}
			case "n":
				(*z).Napping, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Napping")
					return
				}
			case "frd":
				(*z).FastRecoveryDeadline, bts, err = msgp.ReadDurationBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FastRecoveryDeadline")
					return
				}
			case "Pending":
				bts, err = (*z).Pending.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Pending")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *player) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*player)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *player) Msgsize() (s int) {
	s = 1 + 2 + (*z).Round.Msgsize() + 2 + msgp.Uint64Size + 2 + msgp.Uint64Size + 3 + msgp.Uint64Size + 3 + msgp.DurationSize + 2 + msgp.BoolSize + 4 + msgp.DurationSize + 8 + (*z).Pending.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *player) MsgIsZero() bool {
	return ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).LastConcluding == 0) && ((*z).Deadline == 0) && ((*z).Napping == false) && ((*z).FastRecoveryDeadline == 0) && ((*z).Pending.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *proposal) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0004Len := uint32(29)
	var zb0004Mask uint64 /* 38 bits */
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel == 0 {
		zb0004Len--
		zb0004Mask |= 0x40
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue == 0 {
		zb0004Len--
		zb0004Mask |= 0x100
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.GenesisID == "" {
		zb0004Len--
		zb0004Mask |= 0x200
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x400
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x800
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x1000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x2000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0 {
		zb0004Len--
		zb0004Mask |= 0x4000
	}
	if (*z).unauthenticatedProposal.OriginalPeriod == 0 {
		zb0004Len--
		zb0004Mask |= 0x8000
	}
	if (*z).unauthenticatedProposal.OriginalProposer.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x10000
	}
	if len((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) == 0 {
		zb0004Len--
		zb0004Mask |= 0x20000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Branch.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x40000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate == 0 {
		zb0004Len--
		zb0004Mask |= 0x100000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Round.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x400000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x800000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x1000000
	}
	if (*z).unauthenticatedProposal.SeedProof.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x2000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Seed.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x4000000
	}
	if len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking) == 0 {
		zb0004Len--
		zb0004Mask |= 0x8000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter == 0 {
		zb0004Len--
		zb0004Mask |= 0x10000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp == 0 {
		zb0004Len--
		zb0004Mask |= 0x20000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x40000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80000000
	}
	if (*z).unauthenticatedProposal.Block.Payset.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x100000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x200000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x400000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove == false {
		zb0004Len--
		zb0004Mask |= 0x800000000
	}
	// variable map header, size zb0004Len
	o = msgp.AppendMapHeader(o, zb0004Len)
	if zb0004Len != 0 {
		if (zb0004Mask & 0x40) == 0 { // if not empty
			// string "earn"
			o = append(o, 0xa4, 0x65, 0x61, 0x72, 0x6e)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel)
		}
		if (zb0004Mask & 0x80) == 0 { // if not empty
			// string "fees"
			o = append(o, 0xa4, 0x66, 0x65, 0x65, 0x73)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100) == 0 { // if not empty
			// string "frac"
			o = append(o, 0xa4, 0x66, 0x72, 0x61, 0x63)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue)
		}
		if (zb0004Mask & 0x200) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).unauthenticatedProposal.Block.BlockHeader.GenesisID)
		}
		if (zb0004Mask & 0x400) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MarshalMsg(o)
		}
		if (zb0004Mask & 0x800) == 0 { // if not empty
			// string "nextbefore"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MarshalMsg(o)
		}
		if (zb0004Mask & 0x1000) == 0 { // if not empty
			// string "nextproto"
			o = append(o, 0xa9, 0x6e, 0x65, 0x78, 0x74, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MarshalMsg(o)
		}
		if (zb0004Mask & 0x2000) == 0 { // if not empty
			// string "nextswitch"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MarshalMsg(o)
		}
		if (zb0004Mask & 0x4000) == 0 { // if not empty
			// string "nextyes"
			o = append(o, 0xa7, 0x6e, 0x65, 0x78, 0x74, 0x79, 0x65, 0x73)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals)
		}
		if (zb0004Mask & 0x8000) == 0 { // if not empty
			// string "oper"
			o = append(o, 0xa4, 0x6f, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).unauthenticatedProposal.OriginalPeriod))
		}
		if (zb0004Mask & 0x10000) == 0 { // if not empty
			// string "oprop"
			o = append(o, 0xa5, 0x6f, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).unauthenticatedProposal.OriginalProposer.MarshalMsg(o)
		}
		if (zb0004Mask & 0x20000) == 0 { // if not empty
			// string "partupdrmv"
			o = append(o, 0xaa, 0x70, 0x61, 0x72, 0x74, 0x75, 0x70, 0x64, 0x72, 0x6d, 0x76)
			if (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)))
			}
			for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
				o = (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x40000) == 0 { // if not empty
			// string "prev"
			o = append(o, 0xa4, 0x70, 0x72, 0x65, 0x76)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.MarshalMsg(o)
		}
		if (zb0004Mask & 0x80000) == 0 { // if not empty
			// string "proto"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100000) == 0 { // if not empty
			// string "rate"
			o = append(o, 0xa4, 0x72, 0x61, 0x74, 0x65)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate)
		}
		if (zb0004Mask & 0x400000) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.Round.MarshalMsg(o)
		}
		if (zb0004Mask & 0x800000) == 0 { // if not empty
			// string "rwcalr"
			o = append(o, 0xa6, 0x72, 0x77, 0x63, 0x61, 0x6c, 0x72)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MarshalMsg(o)
		}
		if (zb0004Mask & 0x1000000) == 0 { // if not empty
			// string "rwd"
			o = append(o, 0xa3, 0x72, 0x77, 0x64)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MarshalMsg(o)
		}
		if (zb0004Mask & 0x2000000) == 0 { // if not empty
			// string "sdpf"
			o = append(o, 0xa4, 0x73, 0x64, 0x70, 0x66)
			o = (*z).unauthenticatedProposal.SeedProof.MarshalMsg(o)
		}
		if (zb0004Mask & 0x4000000) == 0 { // if not empty
			// string "seed"
			o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.MarshalMsg(o)
		}
		if (zb0004Mask & 0x8000000) == 0 { // if not empty
			// string "spt"
			o = append(o, 0xa3, 0x73, 0x70, 0x74)
			if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendMapHeader(o, uint32(len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking)))
			}
			zb0001_keys := make([]protocol.StateProofType, 0, len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking))
			for zb0001 := range (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking {
				zb0001_keys = append(zb0001_keys, zb0001)
			}
			sort.Sort(protocol.SortStateProofType(zb0001_keys))
			for _, zb0001 := range zb0001_keys {
				zb0002 := (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking[zb0001]
				_ = zb0002
				o = zb0001.MarshalMsg(o)
				o = zb0002.MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x10000000) == 0 { // if not empty
			// string "tc"
			o = append(o, 0xa2, 0x74, 0x63)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter)
		}
		if (zb0004Mask & 0x20000000) == 0 { // if not empty
			// string "ts"
			o = append(o, 0xa2, 0x74, 0x73)
			o = msgp.AppendInt64(o, (*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp)
		}
		if (zb0004Mask & 0x40000000) == 0 { // if not empty
			// string "txn"
			o = append(o, 0xa3, 0x74, 0x78, 0x6e)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MarshalMsg(o)
		}
		if (zb0004Mask & 0x80000000) == 0 { // if not empty
			// string "txn256"
			o = append(o, 0xa6, 0x74, 0x78, 0x6e, 0x32, 0x35, 0x36)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100000000) == 0 { // if not empty
			// string "txns"
			o = append(o, 0xa4, 0x74, 0x78, 0x6e, 0x73)
			o = (*z).unauthenticatedProposal.Block.Payset.MarshalMsg(o)
		}
		if (zb0004Mask & 0x200000000) == 0 { // if not empty
			// string "upgradedelay"
			o = append(o, 0xac, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x64, 0x65, 0x6c, 0x61, 0x79)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MarshalMsg(o)
		}
		if (zb0004Mask & 0x400000000) == 0 { // if not empty
			// string "upgradeprop"
			o = append(o, 0xab, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MarshalMsg(o)
		}
		if (zb0004Mask & 0x800000000) == 0 { // if not empty
			// string "upgradeyes"
			o = append(o, 0xaa, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x79, 0x65, 0x73)
			o = msgp.AppendBool(o, (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove)
		}
	}
	return
}

func (_ *proposal) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposal)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposal) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0004 int
	var zb0005 bool
	zb0004, zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Branch")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Seed")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NativeSha512_256Commitment")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sha256Commitment")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TimeStamp")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FeeSink")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsPool")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsLevel")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRate")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsResidue")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRecalculationRound")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CurrentProtocol")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocol")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolApprovals")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolVoteBefore")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolSwitchOn")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradePropose")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeDelay")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeApprove")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnCounter")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0006 int
			var zb0007 bool
			zb0006, zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
				return
			}
			if zb0006 > protocol.NumStateProofTypes {
				err = msgp.ErrOverflow(uint64(zb0006), uint64(protocol.NumStateProofTypes))
				err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
				return
			}
			if zb0007 {
				(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = nil
			} else if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking == nil {
				(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = make(map[protocol.StateProofType]bookkeeping.StateProofTrackingData, zb0006)
			}
			for zb0006 > 0 {
				var zb0001 protocol.StateProofType
				var zb0002 bookkeeping.StateProofTrackingData
				zb0006--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
					return
				}
				bts, err = zb0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "StateProofTracking", zb0001)
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking[zb0001] = zb0002
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0008 int
			var zb0009 bool
			zb0008, zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts")
				return
			}
			if zb0008 > config.MaxProposedExpiredOnlineAccounts {
				err = msgp.ErrOverflow(uint64(zb0008), uint64(config.MaxProposedExpiredOnlineAccounts))
				err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts")
				return
			}
			if zb0009 {
				(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = nil
			} else if (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts != nil && cap((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) >= zb0008 {
				(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = ((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)[:zb0008]
			} else {
				(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = make([]basics.Address, zb0008)
			}
			for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts", zb0003)
					return
				}
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.Payset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Payset")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.SeedProof.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SeedProof")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			{
				var zb0010 uint64
				zb0010, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "OriginalPeriod")
					return
				}
				(*z).unauthenticatedProposal.OriginalPeriod = period(zb0010)
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.OriginalProposer.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OriginalProposer")
				return
			}
		}
		if zb0004 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0004)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0005 {
			(*z) = proposal{}
		}
		for zb0004 > 0 {
			zb0004--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "prev":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Branch")
					return
				}
			case "seed":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seed")
					return
				}
			case "txn":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NativeSha512_256Commitment")
					return
				}
			case "txn256":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sha256Commitment")
					return
				}
			case "ts":
				(*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TimeStamp")
					return
				}
			case "gen":
				(*z).unauthenticatedProposal.Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
			case "gh":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
			case "fees":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FeeSink")
					return
				}
			case "rwd":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsPool")
					return
				}
			case "earn":
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsLevel")
					return
				}
			case "rate":
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRate")
					return
				}
			case "frac":
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsResidue")
					return
				}
			case "rwcalr":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRecalculationRound")
					return
				}
			case "proto":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CurrentProtocol")
					return
				}
			case "nextproto":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocol")
					return
				}
			case "nextyes":
				(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolApprovals")
					return
				}
			case "nextbefore":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolVoteBefore")
					return
				}
			case "nextswitch":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolSwitchOn")
					return
				}
			case "upgradeprop":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradePropose")
					return
				}
			case "upgradedelay":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeDelay")
					return
				}
			case "upgradeyes":
				(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeApprove")
					return
				}
			case "tc":
				(*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnCounter")
					return
				}
			case "spt":
				var zb0011 int
				var zb0012 bool
				zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StateProofTracking")
					return
				}
				if zb0011 > protocol.NumStateProofTypes {
					err = msgp.ErrOverflow(uint64(zb0011), uint64(protocol.NumStateProofTypes))
					err = msgp.WrapError(err, "StateProofTracking")
					return
				}
				if zb0012 {
					(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = nil
				} else if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking == nil {
					(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = make(map[protocol.StateProofType]bookkeeping.StateProofTrackingData, zb0011)
				}
				for zb0011 > 0 {
					var zb0001 protocol.StateProofType
					var zb0002 bookkeeping.StateProofTrackingData
					zb0011--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "StateProofTracking")
						return
					}
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "StateProofTracking", zb0001)
						return
					}
					(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking[zb0001] = zb0002
				}
			case "partupdrmv":
				var zb0013 int
				var zb0014 bool
				zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExpiredParticipationAccounts")
					return
				}
				if zb0013 > config.MaxProposedExpiredOnlineAccounts {
					err = msgp.ErrOverflow(uint64(zb0013), uint64(config.MaxProposedExpiredOnlineAccounts))
					err = msgp.WrapError(err, "ExpiredParticipationAccounts")
					return
				}
				if zb0014 {
					(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = nil
				} else if (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts != nil && cap((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) >= zb0013 {
					(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = ((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)[:zb0013]
				} else {
					(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = make([]basics.Address, zb0013)
				}
				for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
					bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ExpiredParticipationAccounts", zb0003)
						return
					}
				}
			case "txns":
				bts, err = (*z).unauthenticatedProposal.Block.Payset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Payset")
					return
				}
			case "sdpf":
				bts, err = (*z).unauthenticatedProposal.SeedProof.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SeedProof")
					return
				}
			case "oper":
				{
					var zb0015 uint64
					zb0015, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OriginalPeriod")
						return
					}
					(*z).unauthenticatedProposal.OriginalPeriod = period(zb0015)
				}
			case "oprop":
				bts, err = (*z).unauthenticatedProposal.OriginalProposer.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OriginalProposer")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *proposal) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposal)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposal) Msgsize() (s int) {
	s = 3 + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.Round.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.Branch.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.Seed.Msgsize() + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.Msgsize() + 7 + (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.Msgsize() + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + len((*z).unauthenticatedProposal.Block.BlockHeader.GenesisID) + 3 + (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.Msgsize() + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.Msgsize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.Msgsize() + 6 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.Msgsize() + 10 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.Msgsize() + 8 + msgp.Uint64Size + 11 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.Msgsize() + 11 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.Msgsize() + 12 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.Msgsize() + 13 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.Msgsize() + 11 + msgp.BoolSize + 3 + msgp.Uint64Size + 4 + msgp.MapHeaderSize
	if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking != nil {
		for zb0001, zb0002 := range (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + zb0002.Msgsize()
		}
	}
	s += 11 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
		s += (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].Msgsize()
	}
	s += 5 + (*z).unauthenticatedProposal.Block.Payset.Msgsize() + 5 + (*z).unauthenticatedProposal.SeedProof.Msgsize() + 5 + msgp.Uint64Size + 6 + (*z).unauthenticatedProposal.OriginalProposer.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposal) MsgIsZero() bool {
	return ((*z).unauthenticatedProposal.Block.BlockHeader.Round.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.Branch.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.Seed.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.GenesisID == "") && ((*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove == false) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter == 0) && (len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking) == 0) && (len((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) == 0) && ((*z).unauthenticatedProposal.Block.Payset.MsgIsZero()) && ((*z).unauthenticatedProposal.SeedProof.MsgIsZero()) && ((*z).unauthenticatedProposal.OriginalPeriod == 0) && ((*z).unauthenticatedProposal.OriginalProposer.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *proposalTable) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(2)
	var zb0003Mask uint8 /* 3 bits */
	if len((*z).Pending) == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).PendingNext == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "p"
			o = append(o, 0xa1, 0x70)
			if (*z).Pending == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendMapHeader(o, uint32(len((*z).Pending)))
			}
			zb0001_keys := make([]int, 0, len((*z).Pending))
			for zb0001 := range (*z).Pending {
				zb0001_keys = append(zb0001_keys, zb0001)
			}
			sort.Sort((zb0001_keys))
			for _, zb0001 := range zb0001_keys {
				zb0002 := (*z).Pending[zb0001]
				_ = zb0002
				o = msgp.AppendInt(o, zb0001)
				if zb0002 == nil {
					o = msgp.AppendNil(o)
				} else {
					o = zb0002.MarshalMsg(o)
				}
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "pn"
			o = append(o, 0xa2, 0x70, 0x6e)
			o = msgp.AppendUint64(o, uint64((*z).PendingNext))
		}
	}
	return
}

func (_ *proposalTable) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalTable)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposalTable) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			var zb0005 int
			var zb0006 bool
			zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Pending")
				return
			}
			if zb0006 {
				(*z).Pending = nil
			} else if (*z).Pending == nil {
				(*z).Pending = make(map[int]*messageEvent, zb0005)
			}
			for zb0005 > 0 {
				var zb0001 int
				var zb0002 *messageEvent
				zb0005--
				zb0001, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Pending")
					return
				}
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					zb0002 = nil
				} else {
					if zb0002 == nil {
						zb0002 = new(messageEvent)
					}
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Pending", zb0001)
						return
					}
				}
				(*z).Pending[zb0001] = zb0002
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0007 uint64
				zb0007, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PendingNext")
					return
				}
				(*z).PendingNext = int(zb0007)
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = proposalTable{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "p":
				var zb0008 int
				var zb0009 bool
				zb0008, zb0009, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Pending")
					return
				}
				if zb0009 {
					(*z).Pending = nil
				} else if (*z).Pending == nil {
					(*z).Pending = make(map[int]*messageEvent, zb0008)
				}
				for zb0008 > 0 {
					var zb0001 int
					var zb0002 *messageEvent
					zb0008--
					zb0001, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Pending")
						return
					}
					if msgp.IsNil(bts) {
						bts, err = msgp.ReadNilBytes(bts)
						if err != nil {
							return
						}
						zb0002 = nil
					} else {
						if zb0002 == nil {
							zb0002 = new(messageEvent)
						}
						bts, err = zb0002.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Pending", zb0001)
							return
						}
					}
					(*z).Pending[zb0001] = zb0002
				}
			case "pn":
				{
					var zb0010 uint64
					zb0010, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PendingNext")
						return
					}
					(*z).PendingNext = int(zb0010)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *proposalTable) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalTable)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposalTable) Msgsize() (s int) {
	s = 1 + 2 + msgp.MapHeaderSize
	if (*z).Pending != nil {
		for zb0001, zb0002 := range (*z).Pending {
			_ = zb0001
			_ = zb0002
			s += 0 + msgp.IntSize
			if zb0002 == nil {
				s += msgp.NilSize
			} else {
				s += zb0002.Msgsize()
			}
		}
	}
	s += 3 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposalTable) MsgIsZero() bool {
	return (len((*z).Pending) == 0) && ((*z).PendingNext == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *proposalValue) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 5 bits */
	if (*z).BlockDigest.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).EncodingDigest.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).OriginalPeriod == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).OriginalProposer.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "dig"
			o = append(o, 0xa3, 0x64, 0x69, 0x67)
			o = (*z).BlockDigest.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "encdig"
			o = append(o, 0xa6, 0x65, 0x6e, 0x63, 0x64, 0x69, 0x67)
			o = (*z).EncodingDigest.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "oper"
			o = append(o, 0xa4, 0x6f, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).OriginalPeriod))
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "oprop"
			o = append(o, 0xa5, 0x6f, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).OriginalProposer.MarshalMsg(o)
		}
	}
	return
}

func (_ *proposalValue) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalValue)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposalValue) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0003 uint64
				zb0003, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "OriginalPeriod")
					return
				}
				(*z).OriginalPeriod = period(zb0003)
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).OriginalProposer.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OriginalProposer")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).BlockDigest.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BlockDigest")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).EncodingDigest.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "EncodingDigest")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = proposalValue{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "oper":
				{
					var zb0004 uint64
					zb0004, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OriginalPeriod")
						return
					}
					(*z).OriginalPeriod = period(zb0004)
				}
			case "oprop":
				bts, err = (*z).OriginalProposer.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OriginalProposer")
					return
				}
			case "dig":
				bts, err = (*z).BlockDigest.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BlockDigest")
					return
				}
			case "encdig":
				bts, err = (*z).EncodingDigest.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "EncodingDigest")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *proposalValue) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalValue)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposalValue) Msgsize() (s int) {
	s = 1 + 5 + msgp.Uint64Size + 6 + (*z).OriginalProposer.Msgsize() + 4 + (*z).BlockDigest.Msgsize() + 7 + (*z).EncodingDigest.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposalValue) MsgIsZero() bool {
	return ((*z).OriginalPeriod == 0) && ((*z).OriginalProposer.MsgIsZero()) && ((*z).BlockDigest.MsgIsZero()) && ((*z).EncodingDigest.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *proposerSeed) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "addr"
	o = append(o, 0x82, 0xa4, 0x61, 0x64, 0x64, 0x72)
	o = (*z).Addr.MarshalMsg(o)
	// string "vrf"
	o = append(o, 0xa3, 0x76, 0x72, 0x66)
	o = (*z).VRF.MarshalMsg(o)
	return
}

func (_ *proposerSeed) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposerSeed)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposerSeed) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Addr.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Addr")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).VRF.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VRF")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = proposerSeed{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "addr":
				bts, err = (*z).Addr.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Addr")
					return
				}
			case "vrf":
				bts, err = (*z).VRF.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "VRF")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *proposerSeed) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposerSeed)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposerSeed) Msgsize() (s int) {
	s = 1 + 5 + (*z).Addr.Msgsize() + 4 + (*z).VRF.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposerSeed) MsgIsZero() bool {
	return ((*z).Addr.MsgIsZero()) && ((*z).VRF.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *pseudonodeAction) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 6 bits */
	if (*z).T == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Period == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Proposal.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).Step == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "at"
			o = append(o, 0xa2, 0x61, 0x74)
			o = msgp.AppendUint64(o, uint64((*z).T))
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "p"
			o = append(o, 0xa1, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "pv"
			o = append(o, 0xa2, 0x70, 0x76)
			o = (*z).Proposal.MarshalMsg(o)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "s"
			o = append(o, 0xa1, 0x73)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
	}
	return
}

func (_ *pseudonodeAction) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*pseudonodeAction)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *pseudonodeAction) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0003 uint64
				zb0003, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "T")
					return
				}
				(*z).T = actionType(zb0003)
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0004 uint64
				zb0004, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0004)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0005)
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Proposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposal")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = pseudonodeAction{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "at":
				{
					var zb0006 uint64
					zb0006, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "T")
						return
					}
					(*z).T = actionType(zb0006)
				}
			case "r":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "p":
				{
					var zb0007 uint64
					zb0007, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0007)
				}
			case "s":
				{
					var zb0008 uint64
					zb0008, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0008)
				}
			case "pv":
				bts, err = (*z).Proposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposal")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *pseudonodeAction) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*pseudonodeAction)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *pseudonodeAction) Msgsize() (s int) {
	s = 1 + 3 + msgp.Uint64Size + 2 + (*z).Round.Msgsize() + 2 + msgp.Uint64Size + 2 + msgp.Uint64Size + 3 + (*z).Proposal.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *pseudonodeAction) MsgIsZero() bool {
	return ((*z).T == 0) && ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Proposal.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *rawVote) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 6 bits */
	if (*z).Period == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Proposal.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Round.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).Sender.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).Step == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "prop"
			o = append(o, 0xa4, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).Proposal.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o = (*z).Sender.MarshalMsg(o)
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
	}
	return
}

func (_ *rawVote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*rawVote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *rawVote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0003 uint64
				zb0003, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0003)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0004 uint64
				zb0004, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0004)
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Proposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposal")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = rawVote{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "rnd":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "per":
				{
					var zb0005 uint64
					zb0005, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0005)
				}
			case "step":
				{
					var zb0006 uint64
					zb0006, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0006)
				}
			case "prop":
				bts, err = (*z).Proposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposal")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *rawVote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*rawVote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *rawVote) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Proposal.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *rawVote) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Proposal.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *seedInput) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "alpha"
	o = append(o, 0x82, 0xa5, 0x61, 0x6c, 0x70, 0x68, 0x61)
	o = (*z).Alpha.MarshalMsg(o)
	// string "hist"
	o = append(o, 0xa4, 0x68, 0x69, 0x73, 0x74)
	o = (*z).History.MarshalMsg(o)
	return
}

func (_ *seedInput) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*seedInput)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *seedInput) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Alpha.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Alpha")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).History.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "History")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = seedInput{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "alpha":
				bts, err = (*z).Alpha.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Alpha")
					return
				}
			case "hist":
				bts, err = (*z).History.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "History")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *seedInput) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*seedInput)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *seedInput) Msgsize() (s int) {
	s = 1 + 6 + (*z).Alpha.Msgsize() + 5 + (*z).History.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *seedInput) MsgIsZero() bool {
	return ((*z).Alpha.MsgIsZero()) && ((*z).History.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *selector) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "per"
	o = append(o, 0x84, 0xa3, 0x70, 0x65, 0x72)
	o = msgp.AppendUint64(o, uint64((*z).Period))
	// string "rnd"
	o = append(o, 0xa3, 0x72, 0x6e, 0x64)
	o = (*z).Round.MarshalMsg(o)
	// string "seed"
	o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
	o = (*z).Seed.MarshalMsg(o)
	// string "step"
	o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
	o = msgp.AppendUint64(o, uint64((*z).Step))
	return
}

func (_ *selector) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*selector)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *selector) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Seed.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Seed")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0003 uint64
				zb0003, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0003)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0004 uint64
				zb0004, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0004)
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = selector{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "seed":
				bts, err = (*z).Seed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seed")
					return
				}
			case "rnd":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "per":
				{
					var zb0005 uint64
					zb0005, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0005)
				}
			case "step":
				{
					var zb0006 uint64
					zb0006, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0006)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *selector) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*selector)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *selector) Msgsize() (s int) {
	s = 1 + 5 + (*z).Seed.Msgsize() + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *selector) MsgIsZero() bool {
	return ((*z).Seed.MsgIsZero()) && ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z serializableErrorUnderlying) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

func (_ serializableErrorUnderlying) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(serializableErrorUnderlying)
	if !ok {
		_, ok = (z).(*serializableErrorUnderlying)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *serializableErrorUnderlying) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = serializableErrorUnderlying(zb0001)
	}
	o = bts
	return
}

func (_ *serializableErrorUnderlying) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*serializableErrorUnderlying)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z serializableErrorUnderlying) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MsgIsZero returns whether this is a zero value
func (z serializableErrorUnderlying) MsgIsZero() bool {
	return z == ""
}

// MarshalMsg implements msgp.Marshaler
func (z step) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

func (_ step) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(step)
	if !ok {
		_, ok = (z).(*step)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *step) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint64
		zb0001, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = step(zb0001)
	}
	o = bts
	return
}

func (_ *step) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*step)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z step) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z step) MsgIsZero() bool {
	return z == 0
}

// MarshalMsg implements msgp.Marshaler
func (z *transmittedPayload) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0004Len := uint32(30)
	var zb0004Mask uint64 /* 37 bits */
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel == 0 {
		zb0004Len--
		zb0004Mask |= 0x80
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x100
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue == 0 {
		zb0004Len--
		zb0004Mask |= 0x200
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.GenesisID == "" {
		zb0004Len--
		zb0004Mask |= 0x400
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x800
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x1000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x2000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x4000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0 {
		zb0004Len--
		zb0004Mask |= 0x8000
	}
	if (*z).unauthenticatedProposal.OriginalPeriod == 0 {
		zb0004Len--
		zb0004Mask |= 0x10000
	}
	if (*z).unauthenticatedProposal.OriginalProposer.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x20000
	}
	if len((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) == 0 {
		zb0004Len--
		zb0004Mask |= 0x40000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Branch.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x100000
	}
	if (*z).PriorVote.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x200000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate == 0 {
		zb0004Len--
		zb0004Mask |= 0x400000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Round.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x800000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x1000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x2000000
	}
	if (*z).unauthenticatedProposal.SeedProof.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x4000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Seed.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x8000000
	}
	if len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking) == 0 {
		zb0004Len--
		zb0004Mask |= 0x10000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter == 0 {
		zb0004Len--
		zb0004Mask |= 0x20000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp == 0 {
		zb0004Len--
		zb0004Mask |= 0x40000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x100000000
	}
	if (*z).unauthenticatedProposal.Block.Payset.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x200000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x400000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x800000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove == false {
		zb0004Len--
		zb0004Mask |= 0x1000000000
	}
	// variable map header, size zb0004Len
	o = msgp.AppendMapHeader(o, zb0004Len)
	if zb0004Len != 0 {
		if (zb0004Mask & 0x80) == 0 { // if not empty
			// string "earn"
			o = append(o, 0xa4, 0x65, 0x61, 0x72, 0x6e)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel)
		}
		if (zb0004Mask & 0x100) == 0 { // if not empty
			// string "fees"
			o = append(o, 0xa4, 0x66, 0x65, 0x65, 0x73)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MarshalMsg(o)
		}
		if (zb0004Mask & 0x200) == 0 { // if not empty
			// string "frac"
			o = append(o, 0xa4, 0x66, 0x72, 0x61, 0x63)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue)
		}
		if (zb0004Mask & 0x400) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).unauthenticatedProposal.Block.BlockHeader.GenesisID)
		}
		if (zb0004Mask & 0x800) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MarshalMsg(o)
		}
		if (zb0004Mask & 0x1000) == 0 { // if not empty
			// string "nextbefore"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MarshalMsg(o)
		}
		if (zb0004Mask & 0x2000) == 0 { // if not empty
			// string "nextproto"
			o = append(o, 0xa9, 0x6e, 0x65, 0x78, 0x74, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MarshalMsg(o)
		}
		if (zb0004Mask & 0x4000) == 0 { // if not empty
			// string "nextswitch"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MarshalMsg(o)
		}
		if (zb0004Mask & 0x8000) == 0 { // if not empty
			// string "nextyes"
			o = append(o, 0xa7, 0x6e, 0x65, 0x78, 0x74, 0x79, 0x65, 0x73)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals)
		}
		if (zb0004Mask & 0x10000) == 0 { // if not empty
			// string "oper"
			o = append(o, 0xa4, 0x6f, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).unauthenticatedProposal.OriginalPeriod))
		}
		if (zb0004Mask & 0x20000) == 0 { // if not empty
			// string "oprop"
			o = append(o, 0xa5, 0x6f, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).unauthenticatedProposal.OriginalProposer.MarshalMsg(o)
		}
		if (zb0004Mask & 0x40000) == 0 { // if not empty
			// string "partupdrmv"
			o = append(o, 0xaa, 0x70, 0x61, 0x72, 0x74, 0x75, 0x70, 0x64, 0x72, 0x6d, 0x76)
			if (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)))
			}
			for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
				o = (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x80000) == 0 { // if not empty
			// string "prev"
			o = append(o, 0xa4, 0x70, 0x72, 0x65, 0x76)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100000) == 0 { // if not empty
			// string "proto"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MarshalMsg(o)
		}
		if (zb0004Mask & 0x200000) == 0 { // if not empty
			// string "pv"
			o = append(o, 0xa2, 0x70, 0x76)
			o = (*z).PriorVote.MarshalMsg(o)
		}
		if (zb0004Mask & 0x400000) == 0 { // if not empty
			// string "rate"
			o = append(o, 0xa4, 0x72, 0x61, 0x74, 0x65)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate)
		}
		if (zb0004Mask & 0x800000) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.Round.MarshalMsg(o)
		}
		if (zb0004Mask & 0x1000000) == 0 { // if not empty
			// string "rwcalr"
			o = append(o, 0xa6, 0x72, 0x77, 0x63, 0x61, 0x6c, 0x72)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MarshalMsg(o)
		}
		if (zb0004Mask & 0x2000000) == 0 { // if not empty
			// string "rwd"
			o = append(o, 0xa3, 0x72, 0x77, 0x64)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MarshalMsg(o)
		}
		if (zb0004Mask & 0x4000000) == 0 { // if not empty
			// string "sdpf"
			o = append(o, 0xa4, 0x73, 0x64, 0x70, 0x66)
			o = (*z).unauthenticatedProposal.SeedProof.MarshalMsg(o)
		}
		if (zb0004Mask & 0x8000000) == 0 { // if not empty
			// string "seed"
			o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.MarshalMsg(o)
		}
		if (zb0004Mask & 0x10000000) == 0 { // if not empty
			// string "spt"
			o = append(o, 0xa3, 0x73, 0x70, 0x74)
			if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendMapHeader(o, uint32(len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking)))
			}
			zb0001_keys := make([]protocol.StateProofType, 0, len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking))
			for zb0001 := range (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking {
				zb0001_keys = append(zb0001_keys, zb0001)
			}
			sort.Sort(protocol.SortStateProofType(zb0001_keys))
			for _, zb0001 := range zb0001_keys {
				zb0002 := (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking[zb0001]
				_ = zb0002
				o = zb0001.MarshalMsg(o)
				o = zb0002.MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x20000000) == 0 { // if not empty
			// string "tc"
			o = append(o, 0xa2, 0x74, 0x63)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter)
		}
		if (zb0004Mask & 0x40000000) == 0 { // if not empty
			// string "ts"
			o = append(o, 0xa2, 0x74, 0x73)
			o = msgp.AppendInt64(o, (*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp)
		}
		if (zb0004Mask & 0x80000000) == 0 { // if not empty
			// string "txn"
			o = append(o, 0xa3, 0x74, 0x78, 0x6e)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100000000) == 0 { // if not empty
			// string "txn256"
			o = append(o, 0xa6, 0x74, 0x78, 0x6e, 0x32, 0x35, 0x36)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.MarshalMsg(o)
		}
		if (zb0004Mask & 0x200000000) == 0 { // if not empty
			// string "txns"
			o = append(o, 0xa4, 0x74, 0x78, 0x6e, 0x73)
			o = (*z).unauthenticatedProposal.Block.Payset.MarshalMsg(o)
		}
		if (zb0004Mask & 0x400000000) == 0 { // if not empty
			// string "upgradedelay"
			o = append(o, 0xac, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x64, 0x65, 0x6c, 0x61, 0x79)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MarshalMsg(o)
		}
		if (zb0004Mask & 0x800000000) == 0 { // if not empty
			// string "upgradeprop"
			o = append(o, 0xab, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MarshalMsg(o)
		}
		if (zb0004Mask & 0x1000000000) == 0 { // if not empty
			// string "upgradeyes"
			o = append(o, 0xaa, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x79, 0x65, 0x73)
			o = msgp.AppendBool(o, (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove)
		}
	}
	return
}

func (_ *transmittedPayload) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*transmittedPayload)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *transmittedPayload) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0004 int
	var zb0005 bool
	zb0004, zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Branch")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Seed")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NativeSha512_256Commitment")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sha256Commitment")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TimeStamp")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FeeSink")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsPool")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsLevel")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRate")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsResidue")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRecalculationRound")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CurrentProtocol")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocol")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolApprovals")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolVoteBefore")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolSwitchOn")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradePropose")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeDelay")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeApprove")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnCounter")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0006 int
			var zb0007 bool
			zb0006, zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
				return
			}
			if zb0006 > protocol.NumStateProofTypes {
				err = msgp.ErrOverflow(uint64(zb0006), uint64(protocol.NumStateProofTypes))
				err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
				return
			}
			if zb0007 {
				(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = nil
			} else if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking == nil {
				(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = make(map[protocol.StateProofType]bookkeeping.StateProofTrackingData, zb0006)
			}
			for zb0006 > 0 {
				var zb0001 protocol.StateProofType
				var zb0002 bookkeeping.StateProofTrackingData
				zb0006--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
					return
				}
				bts, err = zb0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "StateProofTracking", zb0001)
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking[zb0001] = zb0002
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0008 int
			var zb0009 bool
			zb0008, zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts")
				return
			}
			if zb0008 > config.MaxProposedExpiredOnlineAccounts {
				err = msgp.ErrOverflow(uint64(zb0008), uint64(config.MaxProposedExpiredOnlineAccounts))
				err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts")
				return
			}
			if zb0009 {
				(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = nil
			} else if (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts != nil && cap((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) >= zb0008 {
				(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = ((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)[:zb0008]
			} else {
				(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = make([]basics.Address, zb0008)
			}
			for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts", zb0003)
					return
				}
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.Payset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Payset")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.SeedProof.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SeedProof")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			{
				var zb0010 uint64
				zb0010, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "OriginalPeriod")
					return
				}
				(*z).unauthenticatedProposal.OriginalPeriod = period(zb0010)
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.OriginalProposer.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OriginalProposer")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).PriorVote.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PriorVote")
				return
			}
		}
		if zb0004 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0004)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0005 {
			(*z) = transmittedPayload{}
		}
		for zb0004 > 0 {
			zb0004--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "prev":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Branch")
					return
				}
			case "seed":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seed")
					return
				}
			case "txn":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NativeSha512_256Commitment")
					return
				}
			case "txn256":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sha256Commitment")
					return
				}
			case "ts":
				(*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TimeStamp")
					return
				}
			case "gen":
				(*z).unauthenticatedProposal.Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
			case "gh":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
			case "fees":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FeeSink")
					return
				}
			case "rwd":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsPool")
					return
				}
			case "earn":
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsLevel")
					return
				}
			case "rate":
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRate")
					return
				}
			case "frac":
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsResidue")
					return
				}
			case "rwcalr":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRecalculationRound")
					return
				}
			case "proto":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CurrentProtocol")
					return
				}
			case "nextproto":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocol")
					return
				}
			case "nextyes":
				(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolApprovals")
					return
				}
			case "nextbefore":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolVoteBefore")
					return
				}
			case "nextswitch":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolSwitchOn")
					return
				}
			case "upgradeprop":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradePropose")
					return
				}
			case "upgradedelay":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeDelay")
					return
				}
			case "upgradeyes":
				(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeApprove")
					return
				}
			case "tc":
				(*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnCounter")
					return
				}
			case "spt":
				var zb0011 int
				var zb0012 bool
				zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StateProofTracking")
					return
				}
				if zb0011 > protocol.NumStateProofTypes {
					err = msgp.ErrOverflow(uint64(zb0011), uint64(protocol.NumStateProofTypes))
					err = msgp.WrapError(err, "StateProofTracking")
					return
				}
				if zb0012 {
					(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = nil
				} else if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking == nil {
					(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = make(map[protocol.StateProofType]bookkeeping.StateProofTrackingData, zb0011)
				}
				for zb0011 > 0 {
					var zb0001 protocol.StateProofType
					var zb0002 bookkeeping.StateProofTrackingData
					zb0011--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "StateProofTracking")
						return
					}
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "StateProofTracking", zb0001)
						return
					}
					(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking[zb0001] = zb0002
				}
			case "partupdrmv":
				var zb0013 int
				var zb0014 bool
				zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExpiredParticipationAccounts")
					return
				}
				if zb0013 > config.MaxProposedExpiredOnlineAccounts {
					err = msgp.ErrOverflow(uint64(zb0013), uint64(config.MaxProposedExpiredOnlineAccounts))
					err = msgp.WrapError(err, "ExpiredParticipationAccounts")
					return
				}
				if zb0014 {
					(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = nil
				} else if (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts != nil && cap((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) >= zb0013 {
					(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = ((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)[:zb0013]
				} else {
					(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = make([]basics.Address, zb0013)
				}
				for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
					bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ExpiredParticipationAccounts", zb0003)
						return
					}
				}
			case "txns":
				bts, err = (*z).unauthenticatedProposal.Block.Payset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Payset")
					return
				}
			case "sdpf":
				bts, err = (*z).unauthenticatedProposal.SeedProof.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SeedProof")
					return
				}
			case "oper":
				{
					var zb0015 uint64
					zb0015, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OriginalPeriod")
						return
					}
					(*z).unauthenticatedProposal.OriginalPeriod = period(zb0015)
				}
			case "oprop":
				bts, err = (*z).unauthenticatedProposal.OriginalProposer.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OriginalProposer")
					return
				}
			case "pv":
				bts, err = (*z).PriorVote.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "PriorVote")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *transmittedPayload) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*transmittedPayload)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *transmittedPayload) Msgsize() (s int) {
	s = 3 + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.Round.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.Branch.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.Seed.Msgsize() + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.Msgsize() + 7 + (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.Msgsize() + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + len((*z).unauthenticatedProposal.Block.BlockHeader.GenesisID) + 3 + (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.Msgsize() + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.Msgsize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.Msgsize() + 6 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.Msgsize() + 10 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.Msgsize() + 8 + msgp.Uint64Size + 11 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.Msgsize() + 11 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.Msgsize() + 12 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.Msgsize() + 13 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.Msgsize() + 11 + msgp.BoolSize + 3 + msgp.Uint64Size + 4 + msgp.MapHeaderSize
	if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking != nil {
		for zb0001, zb0002 := range (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + zb0002.Msgsize()
		}
	}
	s += 11 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
		s += (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].Msgsize()
	}
	s += 5 + (*z).unauthenticatedProposal.Block.Payset.Msgsize() + 5 + (*z).unauthenticatedProposal.SeedProof.Msgsize() + 5 + msgp.Uint64Size + 6 + (*z).unauthenticatedProposal.OriginalProposer.Msgsize() + 3 + (*z).PriorVote.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *transmittedPayload) MsgIsZero() bool {
	return ((*z).unauthenticatedProposal.Block.BlockHeader.Round.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.Branch.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.Seed.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.GenesisID == "") && ((*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove == false) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter == 0) && (len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking) == 0) && (len((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) == 0) && ((*z).unauthenticatedProposal.Block.Payset.MsgIsZero()) && ((*z).unauthenticatedProposal.SeedProof.MsgIsZero()) && ((*z).unauthenticatedProposal.OriginalPeriod == 0) && ((*z).unauthenticatedProposal.OriginalProposer.MsgIsZero()) && ((*z).PriorVote.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *unauthenticatedBundle) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(6)
	var zb0003Mask uint8 /* 7 bits */
	if len((*z).EquivocationVotes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).Period == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if (*z).Proposal.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if (*z).Step == 0 {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if len((*z).Votes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "eqv"
			o = append(o, 0xa3, 0x65, 0x71, 0x76)
			if (*z).EquivocationVotes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).EquivocationVotes)))
			}
			for zb0002 := range (*z).EquivocationVotes {
				o = (*z).EquivocationVotes[zb0002].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "prop"
			o = append(o, 0xa4, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).Proposal.MarshalMsg(o)
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "vote"
			o = append(o, 0xa4, 0x76, 0x6f, 0x74, 0x65)
			if (*z).Votes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Votes)))
			}
			for zb0001 := range (*z).Votes {
				o = (*z).Votes[zb0001].MarshalMsg(o)
			}
		}
	}
	return
}

func (_ *unauthenticatedBundle) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedBundle)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *unauthenticatedBundle) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0005)
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0006 uint64
				zb0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0006)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Proposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposal")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0007 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0007), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0008 {
				(*z).Votes = nil
			} else if (*z).Votes != nil && cap((*z).Votes) >= zb0007 {
				(*z).Votes = ((*z).Votes)[:zb0007]
			} else {
				(*z).Votes = make([]voteAuthenticator, zb0007)
			}
			for zb0001 := range (*z).Votes {
				bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Votes", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0009 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0010 {
				(*z).EquivocationVotes = nil
			} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0009 {
				(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0009]
			} else {
				(*z).EquivocationVotes = make([]equivocationVoteAuthenticator, zb0009)
			}
			for zb0002 := range (*z).EquivocationVotes {
				bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = unauthenticatedBundle{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "per":
				{
					var zb0011 uint64
					zb0011, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0011)
				}
			case "step":
				{
					var zb0012 uint64
					zb0012, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0012)
				}
			case "prop":
				bts, err = (*z).Proposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposal")
					return
				}
			case "vote":
				var zb0013 int
				var zb0014 bool
				zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0013 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0013), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0014 {
					(*z).Votes = nil
				} else if (*z).Votes != nil && cap((*z).Votes) >= zb0013 {
					(*z).Votes = ((*z).Votes)[:zb0013]
				} else {
					(*z).Votes = make([]voteAuthenticator, zb0013)
				}
				for zb0001 := range (*z).Votes {
					bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Votes", zb0001)
						return
					}
				}
			case "eqv":
				var zb0015 int
				var zb0016 bool
				zb0015, zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0015 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0015), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0016 {
					(*z).EquivocationVotes = nil
				} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0015 {
					(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0015]
				} else {
					(*z).EquivocationVotes = make([]equivocationVoteAuthenticator, zb0015)
				}
				for zb0002 := range (*z).EquivocationVotes {
					bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "EquivocationVotes", zb0002)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *unauthenticatedBundle) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedBundle)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *unauthenticatedBundle) Msgsize() (s int) {
	s = 1 + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Proposal.Msgsize() + 5 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Votes {
		s += (*z).Votes[zb0001].Msgsize()
	}
	s += 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).EquivocationVotes {
		s += (*z).EquivocationVotes[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *unauthenticatedBundle) MsgIsZero() bool {
	return ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Proposal.MsgIsZero()) && (len((*z).Votes) == 0) && (len((*z).EquivocationVotes) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *unauthenticatedEquivocationVote) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(7)
	var zb0003Mask uint8 /* 8 bits */
	if (*z).Cred.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).Period == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if ((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero()) {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if ((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero()) {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if (*z).Sender.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	if (*z).Step == 0 {
		zb0003Len--
		zb0003Mask |= 0x80
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "cred"
			o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
			o = (*z).Cred.MarshalMsg(o)
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "props"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x70, 0x73)
			o = msgp.AppendArrayHeader(o, 2)
			for zb0001 := range (*z).Proposals {
				o = (*z).Proposals[zb0001].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "sigs"
			o = append(o, 0xa4, 0x73, 0x69, 0x67, 0x73)
			o = msgp.AppendArrayHeader(o, 2)
			for zb0002 := range (*z).Sigs {
				o = (*z).Sigs[zb0002].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o = (*z).Sender.MarshalMsg(o)
		}
		if (zb0003Mask & 0x80) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
	}
	return
}

func (_ *unauthenticatedEquivocationVote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedEquivocationVote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *unauthenticatedEquivocationVote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0005)
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0006 uint64
				zb0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0006)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			zb0007, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposals")
				return
			}
			if zb0007 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0007}
				return
			}
			for zb0001 := 0; zb0001 < zb0007; zb0001++ {
				bts, err = (*z).Proposals[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Proposals", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0008 int
			zb0008, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sigs")
				return
			}
			if zb0008 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0008}
				return
			}
			for zb0002 := 0; zb0002 < zb0008; zb0002++ {
				bts, err = (*z).Sigs[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sigs", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = unauthenticatedEquivocationVote{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "rnd":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "per":
				{
					var zb0009 uint64
					zb0009, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0009)
				}
			case "step":
				{
					var zb0010 uint64
					zb0010, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0010)
				}
			case "cred":
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
			case "props":
				var zb0011 int
				zb0011, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposals")
					return
				}
				if zb0011 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0011}
					return
				}
				for zb0001 := 0; zb0001 < zb0011; zb0001++ {
					bts, err = (*z).Proposals[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Proposals", zb0001)
						return
					}
				}
			case "sigs":
				var zb0012 int
				zb0012, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sigs")
					return
				}
				if zb0012 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0012}
					return
				}
				for zb0002 := 0; zb0002 < zb0012; zb0002++ {
					bts, err = (*z).Sigs[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sigs", zb0002)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *unauthenticatedEquivocationVote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedEquivocationVote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *unauthenticatedEquivocationVote) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Cred.Msgsize() + 6 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Proposals {
		s += (*z).Proposals[zb0001].Msgsize()
	}
	s += 5 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Sigs {
		s += (*z).Sigs[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *unauthenticatedEquivocationVote) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Cred.MsgIsZero()) && (((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero())) && (((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero()))
}

// MarshalMsg implements msgp.Marshaler
func (z *unauthenticatedProposal) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0004Len := uint32(29)
	var zb0004Mask uint64 /* 35 bits */
	if (*z).Block.BlockHeader.RewardsState.RewardsLevel == 0 {
		zb0004Len--
		zb0004Mask |= 0x40
	}
	if (*z).Block.BlockHeader.RewardsState.FeeSink.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80
	}
	if (*z).Block.BlockHeader.RewardsState.RewardsResidue == 0 {
		zb0004Len--
		zb0004Mask |= 0x100
	}
	if (*z).Block.BlockHeader.GenesisID == "" {
		zb0004Len--
		zb0004Mask |= 0x200
	}
	if (*z).Block.BlockHeader.GenesisHash.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x400
	}
	if (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x800
	}
	if (*z).Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x1000
	}
	if (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x2000
	}
	if (*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0 {
		zb0004Len--
		zb0004Mask |= 0x4000
	}
	if (*z).OriginalPeriod == 0 {
		zb0004Len--
		zb0004Mask |= 0x8000
	}
	if (*z).OriginalProposer.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x10000
	}
	if len((*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) == 0 {
		zb0004Len--
		zb0004Mask |= 0x20000
	}
	if (*z).Block.BlockHeader.Branch.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x40000
	}
	if (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80000
	}
	if (*z).Block.BlockHeader.RewardsState.RewardsRate == 0 {
		zb0004Len--
		zb0004Mask |= 0x100000
	}
	if (*z).Block.BlockHeader.Round.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x200000
	}
	if (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x400000
	}
	if (*z).Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x800000
	}
	if (*z).SeedProof.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x1000000
	}
	if (*z).Block.BlockHeader.Seed.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x2000000
	}
	if len((*z).Block.BlockHeader.StateProofTracking) == 0 {
		zb0004Len--
		zb0004Mask |= 0x4000000
	}
	if (*z).Block.BlockHeader.TxnCounter == 0 {
		zb0004Len--
		zb0004Mask |= 0x8000000
	}
	if (*z).Block.BlockHeader.TimeStamp == 0 {
		zb0004Len--
		zb0004Mask |= 0x10000000
	}
	if (*z).Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x20000000
	}
	if (*z).Block.BlockHeader.TxnCommitments.Sha256Commitment.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x40000000
	}
	if (*z).Block.Payset.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80000000
	}
	if (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x100000000
	}
	if (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x200000000
	}
	if (*z).Block.BlockHeader.UpgradeVote.UpgradeApprove == false {
		zb0004Len--
		zb0004Mask |= 0x400000000
	}
	// variable map header, size zb0004Len
	o = msgp.AppendMapHeader(o, zb0004Len)
	if zb0004Len != 0 {
		if (zb0004Mask & 0x40) == 0 { // if not empty
			// string "earn"
			o = append(o, 0xa4, 0x65, 0x61, 0x72, 0x6e)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.RewardsState.RewardsLevel)
		}
		if (zb0004Mask & 0x80) == 0 { // if not empty
			// string "fees"
			o = append(o, 0xa4, 0x66, 0x65, 0x65, 0x73)
			o = (*z).Block.BlockHeader.RewardsState.FeeSink.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100) == 0 { // if not empty
			// string "frac"
			o = append(o, 0xa4, 0x66, 0x72, 0x61, 0x63)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.RewardsState.RewardsResidue)
		}
		if (zb0004Mask & 0x200) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).Block.BlockHeader.GenesisID)
		}
		if (zb0004Mask & 0x400) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o = (*z).Block.BlockHeader.GenesisHash.MarshalMsg(o)
		}
		if (zb0004Mask & 0x800) == 0 { // if not empty
			// string "nextbefore"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
			o = (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MarshalMsg(o)
		}
		if (zb0004Mask & 0x1000) == 0 { // if not empty
			// string "nextproto"
			o = append(o, 0xa9, 0x6e, 0x65, 0x78, 0x74, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).Block.BlockHeader.UpgradeState.NextProtocol.MarshalMsg(o)
		}
		if (zb0004Mask & 0x2000) == 0 { // if not empty
			// string "nextswitch"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68)
			o = (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MarshalMsg(o)
		}
		if (zb0004Mask & 0x4000) == 0 { // if not empty
			// string "nextyes"
			o = append(o, 0xa7, 0x6e, 0x65, 0x78, 0x74, 0x79, 0x65, 0x73)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals)
		}
		if (zb0004Mask & 0x8000) == 0 { // if not empty
			// string "oper"
			o = append(o, 0xa4, 0x6f, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).OriginalPeriod))
		}
		if (zb0004Mask & 0x10000) == 0 { // if not empty
			// string "oprop"
			o = append(o, 0xa5, 0x6f, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).OriginalProposer.MarshalMsg(o)
		}
		if (zb0004Mask & 0x20000) == 0 { // if not empty
			// string "partupdrmv"
			o = append(o, 0xaa, 0x70, 0x61, 0x72, 0x74, 0x75, 0x70, 0x64, 0x72, 0x6d, 0x76)
			if (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)))
			}
			for zb0003 := range (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
				o = (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x40000) == 0 { // if not empty
			// string "prev"
			o = append(o, 0xa4, 0x70, 0x72, 0x65, 0x76)
			o = (*z).Block.BlockHeader.Branch.MarshalMsg(o)
		}
		if (zb0004Mask & 0x80000) == 0 { // if not empty
			// string "proto"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100000) == 0 { // if not empty
			// string "rate"
			o = append(o, 0xa4, 0x72, 0x61, 0x74, 0x65)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.RewardsState.RewardsRate)
		}
		if (zb0004Mask & 0x200000) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).Block.BlockHeader.Round.MarshalMsg(o)
		}
		if (zb0004Mask & 0x400000) == 0 { // if not empty
			// string "rwcalr"
			o = append(o, 0xa6, 0x72, 0x77, 0x63, 0x61, 0x6c, 0x72)
			o = (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.MarshalMsg(o)
		}
		if (zb0004Mask & 0x800000) == 0 { // if not empty
			// string "rwd"
			o = append(o, 0xa3, 0x72, 0x77, 0x64)
			o = (*z).Block.BlockHeader.RewardsState.RewardsPool.MarshalMsg(o)
		}
		if (zb0004Mask & 0x1000000) == 0 { // if not empty
			// string "sdpf"
			o = append(o, 0xa4, 0x73, 0x64, 0x70, 0x66)
			o = (*z).SeedProof.MarshalMsg(o)
		}
		if (zb0004Mask & 0x2000000) == 0 { // if not empty
			// string "seed"
			o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
			o = (*z).Block.BlockHeader.Seed.MarshalMsg(o)
		}
		if (zb0004Mask & 0x4000000) == 0 { // if not empty
			// string "spt"
			o = append(o, 0xa3, 0x73, 0x70, 0x74)
			if (*z).Block.BlockHeader.StateProofTracking == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendMapHeader(o, uint32(len((*z).Block.BlockHeader.StateProofTracking)))
			}
			zb0001_keys := make([]protocol.StateProofType, 0, len((*z).Block.BlockHeader.StateProofTracking))
			for zb0001 := range (*z).Block.BlockHeader.StateProofTracking {
				zb0001_keys = append(zb0001_keys, zb0001)
			}
			sort.Sort(protocol.SortStateProofType(zb0001_keys))
			for _, zb0001 := range zb0001_keys {
				zb0002 := (*z).Block.BlockHeader.StateProofTracking[zb0001]
				_ = zb0002
				o = zb0001.MarshalMsg(o)
				o = zb0002.MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x8000000) == 0 { // if not empty
			// string "tc"
			o = append(o, 0xa2, 0x74, 0x63)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.TxnCounter)
		}
		if (zb0004Mask & 0x10000000) == 0 { // if not empty
			// string "ts"
			o = append(o, 0xa2, 0x74, 0x73)
			o = msgp.AppendInt64(o, (*z).Block.BlockHeader.TimeStamp)
		}
		if (zb0004Mask & 0x20000000) == 0 { // if not empty
			// string "txn"
			o = append(o, 0xa3, 0x74, 0x78, 0x6e)
			o = (*z).Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MarshalMsg(o)
		}
		if (zb0004Mask & 0x40000000) == 0 { // if not empty
			// string "txn256"
			o = append(o, 0xa6, 0x74, 0x78, 0x6e, 0x32, 0x35, 0x36)
			o = (*z).Block.BlockHeader.TxnCommitments.Sha256Commitment.MarshalMsg(o)
		}
		if (zb0004Mask & 0x80000000) == 0 { // if not empty
			// string "txns"
			o = append(o, 0xa4, 0x74, 0x78, 0x6e, 0x73)
			o = (*z).Block.Payset.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100000000) == 0 { // if not empty
			// string "upgradedelay"
			o = append(o, 0xac, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x64, 0x65, 0x6c, 0x61, 0x79)
			o = (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.MarshalMsg(o)
		}
		if (zb0004Mask & 0x200000000) == 0 { // if not empty
			// string "upgradeprop"
			o = append(o, 0xab, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.MarshalMsg(o)
		}
		if (zb0004Mask & 0x400000000) == 0 { // if not empty
			// string "upgradeyes"
			o = append(o, 0xaa, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x79, 0x65, 0x73)
			o = msgp.AppendBool(o, (*z).Block.BlockHeader.UpgradeVote.UpgradeApprove)
		}
	}
	return
}

func (_ *unauthenticatedProposal) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedProposal)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *unauthenticatedProposal) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0004 int
	var zb0005 bool
	zb0004, zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.Branch.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Branch")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.Seed.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Seed")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NativeSha512_256Commitment")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.TxnCommitments.Sha256Commitment.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sha256Commitment")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TimeStamp")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FeeSink")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsPool")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsLevel")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRate")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsResidue")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRecalculationRound")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CurrentProtocol")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocol")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolApprovals")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolVoteBefore")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolSwitchOn")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradePropose")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeDelay")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeApprove")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnCounter")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0006 int
			var zb0007 bool
			zb0006, zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
				return
			}
			if zb0006 > protocol.NumStateProofTypes {
				err = msgp.ErrOverflow(uint64(zb0006), uint64(protocol.NumStateProofTypes))
				err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
				return
			}
			if zb0007 {
				(*z).Block.BlockHeader.StateProofTracking = nil
			} else if (*z).Block.BlockHeader.StateProofTracking == nil {
				(*z).Block.BlockHeader.StateProofTracking = make(map[protocol.StateProofType]bookkeeping.StateProofTrackingData, zb0006)
			}
			for zb0006 > 0 {
				var zb0001 protocol.StateProofType
				var zb0002 bookkeeping.StateProofTrackingData
				zb0006--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
					return
				}
				bts, err = zb0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "StateProofTracking", zb0001)
					return
				}
				(*z).Block.BlockHeader.StateProofTracking[zb0001] = zb0002
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0008 int
			var zb0009 bool
			zb0008, zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts")
				return
			}
			if zb0008 > config.MaxProposedExpiredOnlineAccounts {
				err = msgp.ErrOverflow(uint64(zb0008), uint64(config.MaxProposedExpiredOnlineAccounts))
				err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts")
				return
			}
			if zb0009 {
				(*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = nil
			} else if (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts != nil && cap((*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) >= zb0008 {
				(*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = ((*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)[:zb0008]
			} else {
				(*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = make([]basics.Address, zb0008)
			}
			for zb0003 := range (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
				bts, err = (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts", zb0003)
					return
				}
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.Payset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Payset")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).SeedProof.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SeedProof")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			{
				var zb0010 uint64
				zb0010, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "OriginalPeriod")
					return
				}
				(*z).OriginalPeriod = period(zb0010)
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).OriginalProposer.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OriginalProposer")
				return
			}
		}
		if zb0004 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0004)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0005 {
			(*z) = unauthenticatedProposal{}
		}
		for zb0004 > 0 {
			zb0004--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				bts, err = (*z).Block.BlockHeader.Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "prev":
				bts, err = (*z).Block.BlockHeader.Branch.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Branch")
					return
				}
			case "seed":
				bts, err = (*z).Block.BlockHeader.Seed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seed")
					return
				}
			case "txn":
				bts, err = (*z).Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NativeSha512_256Commitment")
					return
				}
			case "txn256":
				bts, err = (*z).Block.BlockHeader.TxnCommitments.Sha256Commitment.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sha256Commitment")
					return
				}
			case "ts":
				(*z).Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TimeStamp")
					return
				}
			case "gen":
				(*z).Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
			case "gh":
				bts, err = (*z).Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
			case "fees":
				bts, err = (*z).Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FeeSink")
					return
				}
			case "rwd":
				bts, err = (*z).Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsPool")
					return
				}
			case "earn":
				(*z).Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsLevel")
					return
				}
			case "rate":
				(*z).Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRate")
					return
				}
			case "frac":
				(*z).Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsResidue")
					return
				}
			case "rwcalr":
				bts, err = (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRecalculationRound")
					return
				}
			case "proto":
				bts, err = (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CurrentProtocol")
					return
				}
			case "nextproto":
				bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocol")
					return
				}
			case "nextyes":
				(*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolApprovals")
					return
				}
			case "nextbefore":
				bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolVoteBefore")
					return
				}
			case "nextswitch":
				bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolSwitchOn")
					return
				}
			case "upgradeprop":
				bts, err = (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradePropose")
					return
				}
			case "upgradedelay":
				bts, err = (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeDelay")
					return
				}
			case "upgradeyes":
				(*z).Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeApprove")
					return
				}
			case "tc":
				(*z).Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnCounter")
					return
				}
			case "spt":
				var zb0011 int
				var zb0012 bool
				zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StateProofTracking")
					return
				}
				if zb0011 > protocol.NumStateProofTypes {
					err = msgp.ErrOverflow(uint64(zb0011), uint64(protocol.NumStateProofTypes))
					err = msgp.WrapError(err, "StateProofTracking")
					return
				}
				if zb0012 {
					(*z).Block.BlockHeader.StateProofTracking = nil
				} else if (*z).Block.BlockHeader.StateProofTracking == nil {
					(*z).Block.BlockHeader.StateProofTracking = make(map[protocol.StateProofType]bookkeeping.StateProofTrackingData, zb0011)
				}
				for zb0011 > 0 {
					var zb0001 protocol.StateProofType
					var zb0002 bookkeeping.StateProofTrackingData
					zb0011--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "StateProofTracking")
						return
					}
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "StateProofTracking", zb0001)
						return
					}
					(*z).Block.BlockHeader.StateProofTracking[zb0001] = zb0002
				}
			case "partupdrmv":
				var zb0013 int
				var zb0014 bool
				zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExpiredParticipationAccounts")
					return
				}
				if zb0013 > config.MaxProposedExpiredOnlineAccounts {
					err = msgp.ErrOverflow(uint64(zb0013), uint64(config.MaxProposedExpiredOnlineAccounts))
					err = msgp.WrapError(err, "ExpiredParticipationAccounts")
					return
				}
				if zb0014 {
					(*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = nil
				} else if (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts != nil && cap((*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) >= zb0013 {
					(*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = ((*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)[:zb0013]
				} else {
					(*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = make([]basics.Address, zb0013)
				}
				for zb0003 := range (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
					bts, err = (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ExpiredParticipationAccounts", zb0003)
						return
					}
				}
			case "txns":
				bts, err = (*z).Block.Payset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Payset")
					return
				}
			case "sdpf":
				bts, err = (*z).SeedProof.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SeedProof")
					return
				}
			case "oper":
				{
					var zb0015 uint64
					zb0015, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OriginalPeriod")
						return
					}
					(*z).OriginalPeriod = period(zb0015)
				}
			case "oprop":
				bts, err = (*z).OriginalProposer.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OriginalProposer")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *unauthenticatedProposal) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedProposal)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *unauthenticatedProposal) Msgsize() (s int) {
	s = 3 + 4 + (*z).Block.BlockHeader.Round.Msgsize() + 5 + (*z).Block.BlockHeader.Branch.Msgsize() + 5 + (*z).Block.BlockHeader.Seed.Msgsize() + 4 + (*z).Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.Msgsize() + 7 + (*z).Block.BlockHeader.TxnCommitments.Sha256Commitment.Msgsize() + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + len((*z).Block.BlockHeader.GenesisID) + 3 + (*z).Block.BlockHeader.GenesisHash.Msgsize() + 5 + (*z).Block.BlockHeader.RewardsState.FeeSink.Msgsize() + 4 + (*z).Block.BlockHeader.RewardsState.RewardsPool.Msgsize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.Msgsize() + 6 + (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.Msgsize() + 10 + (*z).Block.BlockHeader.UpgradeState.NextProtocol.Msgsize() + 8 + msgp.Uint64Size + 11 + (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.Msgsize() + 11 + (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.Msgsize() + 12 + (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.Msgsize() + 13 + (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.Msgsize() + 11 + msgp.BoolSize + 3 + msgp.Uint64Size + 4 + msgp.MapHeaderSize
	if (*z).Block.BlockHeader.StateProofTracking != nil {
		for zb0001, zb0002 := range (*z).Block.BlockHeader.StateProofTracking {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + zb0002.Msgsize()
		}
	}
	s += 11 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
		s += (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].Msgsize()
	}
	s += 5 + (*z).Block.Payset.Msgsize() + 5 + (*z).SeedProof.Msgsize() + 5 + msgp.Uint64Size + 6 + (*z).OriginalProposer.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *unauthenticatedProposal) MsgIsZero() bool {
	return ((*z).Block.BlockHeader.Round.MsgIsZero()) && ((*z).Block.BlockHeader.Branch.MsgIsZero()) && ((*z).Block.BlockHeader.Seed.MsgIsZero()) && ((*z).Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MsgIsZero()) && ((*z).Block.BlockHeader.TxnCommitments.Sha256Commitment.MsgIsZero()) && ((*z).Block.BlockHeader.TimeStamp == 0) && ((*z).Block.BlockHeader.GenesisID == "") && ((*z).Block.BlockHeader.GenesisHash.MsgIsZero()) && ((*z).Block.BlockHeader.RewardsState.FeeSink.MsgIsZero()) && ((*z).Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero()) && ((*z).Block.BlockHeader.RewardsState.RewardsLevel == 0) && ((*z).Block.BlockHeader.RewardsState.RewardsRate == 0) && ((*z).Block.BlockHeader.RewardsState.RewardsResidue == 0) && ((*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0) && ((*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeVote.UpgradeApprove == false) && ((*z).Block.BlockHeader.TxnCounter == 0) && (len((*z).Block.BlockHeader.StateProofTracking) == 0) && (len((*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) == 0) && ((*z).Block.Payset.MsgIsZero()) && ((*z).SeedProof.MsgIsZero()) && ((*z).OriginalPeriod == 0) && ((*z).OriginalProposer.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *unauthenticatedVote) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if (*z).Cred.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).R.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "cred"
			o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
			o = (*z).Cred.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = (*z).R.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o = (*z).Sig.MarshalMsg(o)
		}
	}
	return
}

func (_ *unauthenticatedVote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedVote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *unauthenticatedVote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).R.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "R")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = unauthenticatedVote{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "r":
				bts, err = (*z).R.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "R")
					return
				}
			case "cred":
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
			case "sig":
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *unauthenticatedVote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedVote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *unauthenticatedVote) Msgsize() (s int) {
	s = 1 + 2 + (*z).R.Msgsize() + 5 + (*z).Cred.Msgsize() + 4 + (*z).Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *unauthenticatedVote) MsgIsZero() bool {
	return ((*z).R.MsgIsZero()) && ((*z).Cred.MsgIsZero()) && ((*z).Sig.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *vote) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if (*z).Cred.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).R.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "cred"
			o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
			o = (*z).Cred.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = (*z).R.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o = (*z).Sig.MarshalMsg(o)
		}
	}
	return
}

func (_ *vote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*vote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *vote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).R.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "R")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = vote{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "r":
				bts, err = (*z).R.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "R")
					return
				}
			case "cred":
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
			case "sig":
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *vote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*vote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *vote) Msgsize() (s int) {
	s = 1 + 2 + (*z).R.Msgsize() + 5 + (*z).Cred.Msgsize() + 4 + (*z).Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *vote) MsgIsZero() bool {
	return ((*z).R.MsgIsZero()) && ((*z).Cred.MsgIsZero()) && ((*z).Sig.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *voteAuthenticator) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if (*z).Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		// string "cred"
		o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
		o = (*z).Cred.MarshalMsg(o)
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o = (*z).Sig.MarshalMsg(o)
		}
		// string "snd"
		o = append(o, 0xa3, 0x73, 0x6e, 0x64)
		o = (*z).Sender.MarshalMsg(o)
	}
	return
}

func (_ *voteAuthenticator) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteAuthenticator)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *voteAuthenticator) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = voteAuthenticator{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "cred":
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
			case "sig":
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *voteAuthenticator) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteAuthenticator)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *voteAuthenticator) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 5 + (*z).Cred.Msgsize() + 4 + (*z).Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *voteAuthenticator) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Cred.MsgIsZero()) && ((*z).Sig.MsgIsZero())
}
